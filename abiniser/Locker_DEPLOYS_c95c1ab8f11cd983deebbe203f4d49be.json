{
  "contractName": "Locker",
  "abiHash": "c95c1ab8f11cd983deebbe203f4d49be",
  "networks": {
    "4": {
      "latest": {
        "address": "0xfb6b4803c590e564a3e6810289ab638b353a1367",
        "generatedAt": "2018-04-23T20:18:33.249Z",
        "compiler": {
          "name": "solc",
          "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
        },
        "byteCodeHash": "1ee8107823c445557e111187d4dc2fe1",
        "sourceHash": "d32907ca14fc212ac860efcefb66c83b",
        "source": "/* contract for tracking locked funds etc.\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n    - monetarySupervisor setter?\n\n to do/think about:\n  -> self-destruct function?\n  -> return only active loan products from getLoanProducts?\n*/\n\npragma solidity 0.4.19;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs, bool isActive);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    function Locker(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId);\n        NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n\n        require(lockProductId < lockProducts.length);\n        lockProducts[lockProductId].isActive = isActive;\n        LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    function releaseFunds(uint lockId) external {\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive);\n        require(now >= lock.lockedUntil);\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        LockReleased(lock.owner, lockId);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint32[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs,\n                                        lockProduct.minimumLockAmount, lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) public {\n        require(msg.sender == address(augmintToken));\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId);\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive);\n        require(amountToLock >= lockProduct.minimumLockAmount);\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration);\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs, true);\n    }\n\n}\n"
      }
    },
    "999": {
      "latest": {
        "address": "0xc56757df630980ddcd4e788d0ccf73574a1838ab",
        "generatedAt": "2018-04-23T20:18:33.249Z",
        "compiler": {
          "name": "solc",
          "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
        },
        "byteCodeHash": "1ee8107823c445557e111187d4dc2fe1",
        "sourceHash": "d32907ca14fc212ac860efcefb66c83b",
        "source": "/* contract for tracking locked funds etc.\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n    - monetarySupervisor setter?\n\n to do/think about:\n  -> self-destruct function?\n  -> return only active loan products from getLoanProducts?\n*/\n\npragma solidity 0.4.19;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs, bool isActive);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    function Locker(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId);\n        NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n\n        require(lockProductId < lockProducts.length);\n        lockProducts[lockProductId].isActive = isActive;\n        LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    function releaseFunds(uint lockId) external {\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive);\n        require(now >= lock.lockedUntil);\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        LockReleased(lock.owner, lockId);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint32[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs,\n                                        lockProduct.minimumLockAmount, lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) public {\n        require(msg.sender == address(augmintToken));\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId);\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive);\n        require(amountToLock >= lockProduct.minimumLockAmount);\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration);\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs, true);\n    }\n\n}\n"
      }
    }
  }
}