{
  "contractName": "LoanManager",
  "abiHash": "d72d3bd9689dba0d1a8cd4ec23757257",
  "networks": {
    "4": {
      "latest": {
        "address": "0xec5e35d8941386c3e08019b0ad1d4a8c40c7bcbc",
        "generatedAt": "2018-04-23T20:18:33.224Z",
        "compiler": {
          "name": "solc",
          "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
        },
        "byteCodeHash": "9aa1d3b1d7b1c4593514e33e4854ac41",
        "sourceHash": "5663e971bf347b437fd2860c13e65ea1",
        "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - interestEarnedAccount setter?\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - create and use InterestEarnedAccount interface instead?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity 0.4.19;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./InterestEarnedAccount.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted {\n    using SafeMath for uint256;\n\n    uint16 public constant CHUNK_SIZE = 100;\n\n    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n\n    struct LoanProduct {\n        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n        uint32 term;            // 1\n        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n                                //      in parts per million , ie. 10,000 = 1%\n        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive;          // 5\n    }\n\n    /* NB: we don't need to store loan parameters because loan products can't be altered (only disabled/enabled) */\n    struct LoanData {\n        uint collateralAmount; // 0\n        uint repaymentAmount; // 1\n        address borrower; // 2\n        uint32 productId; // 3\n        LoanState state; // 4\n        uint40 maturity; // 5\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n    InterestEarnedAccount public interestEarnedAccount;\n\n    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount, uint40 maturity);\n\n    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n\n    event LoanProductAdded(uint32 productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    function LoanManager(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor, Rates _rates,\n                            InterestEarnedAccount _interestEarnedAccount)\n    public {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n        interestEarnedAccount = _interestEarnedAccount;\n    }\n\n    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n                                uint32 defaultingFeePt, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newProductId = products.push(\n            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n        ) - 1;\n\n        uint32 newProductId = uint32(_newProductId);\n        require(newProductId == _newProductId);\n\n        LoanProductAdded(newProductId);\n    }\n\n    function setLoanProductActiveState(uint32 productId, bool newState)\n    external restrict (\"MonetaryBoard\") {\n        products[productId].isActive = false;\n        LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint32 productId) external payable {\n        LoanProduct storage product = products[productId];\n        require(product.isActive); // valid productId?\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n\n        uint loanAmount;\n        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n\n        require(loanAmount >= product.minDisbursedAmount);\n\n        uint expiration = now.add(product.term);\n        uint40 maturity = uint40(expiration);\n        require(maturity == expiration);\n\n        // Create new loan\n        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n                                            productId, LoanState.Open, maturity)) - 1;\n\n        // Store ref to new loan\n        accountLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        for (uint i = 0; i < loanIds.length; i++) {\n            LoanData storage loan = loans[loanIds[i]];\n            require(loan.state == LoanState.Open);\n            require(now >= loan.maturity);\n            LoanProduct storage product = products[loan.productId];\n\n            uint loanAmount;\n            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n\n            loan.state = LoanState.Collected;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n                                                            loan.repaymentAmount).add(defaultingFee);\n\n            uint releasedCollateral;\n            if (targetCollection < loan.collateralAmount) {\n                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n                loan.borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n            if (defaultingFee > collateralToCollect) {\n                defaultingFee = collateralToCollect;\n            }\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            LoanCollected(loanIds[i], loan.borrower, collateralToCollect, releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            monetarySupervisor.augmintReserves().transfer(totalCollateralToCollect);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    function getProductCount() external view returns (uint ct) {\n        return products.length;\n    }\n\n    // returns CHUNK_SIZE loan products starting from some offset:\n    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive ]\n    function getProducts(uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= products.length) { break; }\n\n            LoanProduct storage product = products[offset + i];\n\n            response[i] = [offset + i, product.minDisbursedAmount, product.term, product.discountRate,\n                                product.collateralRatio, product.defaultingFeePt, product.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLoanCount() external view returns (uint ct) {\n        return loans.length;\n    }\n\n    /* returns CHUNK_SIZE loans starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ]   */\n    function getLoans(uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loans.length) { break; }\n\n            response[i] = getLoanTuple(offset + i);\n        }\n    }\n\n    function getLoanCountForAddress(address borrower) external view returns (uint) {\n        return accountLoans[borrower].length;\n    }\n\n    /* returns CHUNK_SIZE loans of a given account, starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ] */\n    function getLoansForAddress(address borrower, uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        uint[] storage loansForAddress = accountLoans[borrower];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loansForAddress.length) { break; }\n\n            response[i] = getLoanTuple(loansForAddress[offset + i]);\n        }\n    }\n\n    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n        LoanData storage loan = loans[loanId];\n        LoanProduct storage product = products[loan.productId];\n\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n        uint disbursementTime = loan.maturity - product.term;\n\n        LoanState loanState =\n                        loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n\n        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n                    loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) public {\n        require(msg.sender == address(augmintToken));\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n    internal view returns (uint loanAmount, uint interestAmount) {\n        // calculate loan values based on repayment amount\n        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        LoanData storage loan = loans[loanId];\n        require(loan.state == LoanState.Open);\n        require(repaymentAmount == loan.repaymentAmount);\n        require(now <= loan.maturity);\n\n        LoanProduct storage product = products[loan.productId];\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n\n        loans[loanId].state = LoanState.Repaid;\n\n        if (interestAmount > 0) {\n            augmintToken.transfer(interestEarnedAccount, interestAmount);\n            augmintToken.burn(loanAmount);\n        } else {\n            // negative or zero interest (i.e. discountRate >= 0)\n            augmintToken.burn(repaymentAmount);\n        }\n\n        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n\n        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n\n        LoanRepayed(loanId, loan.borrower);\n    }\n\n}\n"
      }
    },
    "999": {
      "latest": {
        "address": "0x6d3c4ce65b4b1267804e011120f3359d44a3a1a3",
        "generatedAt": "2018-04-23T20:18:33.224Z",
        "compiler": {
          "name": "solc",
          "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
        },
        "byteCodeHash": "9aa1d3b1d7b1c4593514e33e4854ac41",
        "sourceHash": "5663e971bf347b437fd2860c13e65ea1",
        "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - interestEarnedAccount setter?\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - create and use InterestEarnedAccount interface instead?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity 0.4.19;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./InterestEarnedAccount.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted {\n    using SafeMath for uint256;\n\n    uint16 public constant CHUNK_SIZE = 100;\n\n    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n\n    struct LoanProduct {\n        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n        uint32 term;            // 1\n        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n                                //      in parts per million , ie. 10,000 = 1%\n        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive;          // 5\n    }\n\n    /* NB: we don't need to store loan parameters because loan products can't be altered (only disabled/enabled) */\n    struct LoanData {\n        uint collateralAmount; // 0\n        uint repaymentAmount; // 1\n        address borrower; // 2\n        uint32 productId; // 3\n        LoanState state; // 4\n        uint40 maturity; // 5\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n    InterestEarnedAccount public interestEarnedAccount;\n\n    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount, uint40 maturity);\n\n    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n\n    event LoanProductAdded(uint32 productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    function LoanManager(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor, Rates _rates,\n                            InterestEarnedAccount _interestEarnedAccount)\n    public {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n        interestEarnedAccount = _interestEarnedAccount;\n    }\n\n    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n                                uint32 defaultingFeePt, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newProductId = products.push(\n            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n        ) - 1;\n\n        uint32 newProductId = uint32(_newProductId);\n        require(newProductId == _newProductId);\n\n        LoanProductAdded(newProductId);\n    }\n\n    function setLoanProductActiveState(uint32 productId, bool newState)\n    external restrict (\"MonetaryBoard\") {\n        products[productId].isActive = false;\n        LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint32 productId) external payable {\n        LoanProduct storage product = products[productId];\n        require(product.isActive); // valid productId?\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n\n        uint loanAmount;\n        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n\n        require(loanAmount >= product.minDisbursedAmount);\n\n        uint expiration = now.add(product.term);\n        uint40 maturity = uint40(expiration);\n        require(maturity == expiration);\n\n        // Create new loan\n        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n                                            productId, LoanState.Open, maturity)) - 1;\n\n        // Store ref to new loan\n        accountLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        for (uint i = 0; i < loanIds.length; i++) {\n            LoanData storage loan = loans[loanIds[i]];\n            require(loan.state == LoanState.Open);\n            require(now >= loan.maturity);\n            LoanProduct storage product = products[loan.productId];\n\n            uint loanAmount;\n            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n\n            loan.state = LoanState.Collected;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n                                                            loan.repaymentAmount).add(defaultingFee);\n\n            uint releasedCollateral;\n            if (targetCollection < loan.collateralAmount) {\n                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n                loan.borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n            if (defaultingFee > collateralToCollect) {\n                defaultingFee = collateralToCollect;\n            }\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            LoanCollected(loanIds[i], loan.borrower, collateralToCollect, releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            monetarySupervisor.augmintReserves().transfer(totalCollateralToCollect);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    function getProductCount() external view returns (uint ct) {\n        return products.length;\n    }\n\n    // returns CHUNK_SIZE loan products starting from some offset:\n    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive ]\n    function getProducts(uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= products.length) { break; }\n\n            LoanProduct storage product = products[offset + i];\n\n            response[i] = [offset + i, product.minDisbursedAmount, product.term, product.discountRate,\n                                product.collateralRatio, product.defaultingFeePt, product.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLoanCount() external view returns (uint ct) {\n        return loans.length;\n    }\n\n    /* returns CHUNK_SIZE loans starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ]   */\n    function getLoans(uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loans.length) { break; }\n\n            response[i] = getLoanTuple(offset + i);\n        }\n    }\n\n    function getLoanCountForAddress(address borrower) external view returns (uint) {\n        return accountLoans[borrower].length;\n    }\n\n    /* returns CHUNK_SIZE loans of a given account, starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ] */\n    function getLoansForAddress(address borrower, uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        uint[] storage loansForAddress = accountLoans[borrower];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loansForAddress.length) { break; }\n\n            response[i] = getLoanTuple(loansForAddress[offset + i]);\n        }\n    }\n\n    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n        LoanData storage loan = loans[loanId];\n        LoanProduct storage product = products[loan.productId];\n\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n        uint disbursementTime = loan.maturity - product.term;\n\n        LoanState loanState =\n                        loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n\n        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n                    loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) public {\n        require(msg.sender == address(augmintToken));\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n    internal view returns (uint loanAmount, uint interestAmount) {\n        // calculate loan values based on repayment amount\n        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        LoanData storage loan = loans[loanId];\n        require(loan.state == LoanState.Open);\n        require(repaymentAmount == loan.repaymentAmount);\n        require(now <= loan.maturity);\n\n        LoanProduct storage product = products[loan.productId];\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n\n        loans[loanId].state = LoanState.Repaid;\n\n        if (interestAmount > 0) {\n            augmintToken.transfer(interestEarnedAccount, interestAmount);\n            augmintToken.burn(loanAmount);\n        } else {\n            // negative or zero interest (i.e. discountRate >= 0)\n            augmintToken.burn(repaymentAmount);\n        }\n\n        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n\n        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n\n        LoanRepayed(loanId, loan.borrower);\n    }\n\n}\n"
      }
    }
  }
}