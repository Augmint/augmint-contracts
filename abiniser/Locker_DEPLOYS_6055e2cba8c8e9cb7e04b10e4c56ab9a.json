{
  "contractName": "Locker",
  "abiHash": "6055e2cba8c8e9cb7e04b10e4c56ab9a",
  "networks": {
    "4": {
      "latest": {
        "address": "0x617cf9ba5c9cbecdd66412bc1d073b002aa26426",
        "generatedAt": "2018-04-23T20:17:34.387Z",
        "compiler": {
          "name": "solc",
          "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
        },
        "byteCodeHash": "66f7b66ff12fcb40830b0b95777fb852",
        "sourceHash": "1135716bfcd72d7542f37f36acc8673e",
        "source": "/* contract for tracking locked funds etc.\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO:\n  - create  MonetarySupervisorInterface and use it instead of MonetarySupervisor\n  - monetarySupervisor setter?\n  - store locks in array so we can iterate over them\n\n to do/think about:\n  -> self-destruct function?\n  -> return only active loan products from getLoanProducts?\n*/\n\npragma solidity 0.4.19;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    event NewLockProduct(uint indexed lockProductId, uint perTermInterest, uint durationInSecs,\n                            uint minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint indexed lockIndex, uint amountLocked, uint interestEarned,\n                    uint lockedUntil, uint perTermInterest, uint durationInSecs, bool isActive);\n\n    event LockReleased(address indexed lockOwner, uint indexed lockIndex);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint perTermInterest;\n        uint durationInSecs;\n        uint minimumLockAmount;\n        bool isActive;\n    }\n\n    struct Lock {\n        uint amountLocked;\n        uint interestEarned;\n        uint lockedUntil;\n        uint perTermInterest;\n        uint durationInSecs;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n    // per account locks (i.e. an id for a lock is a tuple (owner, index)):\n    mapping(address => Lock[]) public locks;\n\n    function Locker(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint perTermInterest, uint durationInSecs, uint minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n\n        require(lockProductId < lockProducts.length);\n        lockProducts[lockProductId].isActive = isActive;\n        LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    function releaseFunds(address lockOwner, uint lockIndex) external {\n\n        Lock storage lock = locks[lockOwner][lockIndex];\n\n        require(lock.isActive && now >= lock.lockedUntil);\n\n        lock.isActive = false;\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked);   // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lockOwner, lock.amountLocked.add(lock.interestEarned),\n                                                                                \"Funds released from lock\");\n\n        LockReleased(lockOwner, lockIndex);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[4][20]) {\n\n        uint[4][20] memory response;\n\n        for (uint8 i = 0; i < 20; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs,\n                                        lockProduct.minimumLockAmount, lockProduct.isActive ? 1 : 0 ];\n\n        }\n\n        return response;\n\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n\n        return locks[lockOwner].length;\n\n    }\n\n    // returns 20 locks starting from some offset\n    // lock products are encoded as\n    //              [amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[6][20]) {\n\n        Lock[] storage locksForAddress = locks[lockOwner];\n        uint[6][20] memory response;\n\n        for (uint8 i = 0; i < 20; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locksForAddress[offset + i];\n\n            response[i] = [ lock.amountLocked, lock.interestEarned, lock.lockedUntil, lock.perTermInterest,\n                                        lock.durationInSecs, lock.isActive ? 1 : 0 ];\n\n        }\n\n        return response;\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint lockProductId) public {\n        require(msg.sender == address(augmintToken));\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function calculateInterestForLockProduct(uint lockProductId, uint amountToLock) public view returns (uint) {\n\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive);\n        require(amountToLock >= lockProduct.minimumLockAmount);\n\n        uint interestEarned = amountToLock.mul(lockProduct.perTermInterest).div(1000000);\n\n        return interestEarned;\n\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint lockProductId, address lockOwner, uint amountToLock) internal returns (uint) {\n\n        // NB: calculateInterestForLockProduct will validate the lock product and amountToLock:\n        uint interestEarned = calculateInterestForLockProduct(lockProductId, amountToLock);\n\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n\n        uint lockedUntil = now.add(lockProduct.durationInSecs);\n        uint lockIndex = locks[lockOwner].push(Lock(amountToLock, interestEarned, lockedUntil,\n                                                    lockProduct.perTermInterest, lockProduct.durationInSecs, true)) - 1;\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        NewLock(lockOwner, lockIndex, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs, true);\n\n        return interestEarned;\n    }\n\n}\n"
      }
    },
    "999": {
      "latest": {
        "address": "0x8fd4d02f46ec6c92924780d2bf35ae31078db9c5",
        "generatedAt": "2018-04-23T20:17:34.387Z",
        "compiler": {
          "name": "solc",
          "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
        },
        "byteCodeHash": "66f7b66ff12fcb40830b0b95777fb852",
        "sourceHash": "1135716bfcd72d7542f37f36acc8673e",
        "source": "/* contract for tracking locked funds etc.\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO:\n  - create  MonetarySupervisorInterface and use it instead of MonetarySupervisor\n  - monetarySupervisor setter?\n  - store locks in array so we can iterate over them\n\n to do/think about:\n  -> self-destruct function?\n  -> return only active loan products from getLoanProducts?\n*/\n\npragma solidity 0.4.19;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    event NewLockProduct(uint indexed lockProductId, uint perTermInterest, uint durationInSecs,\n                            uint minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint indexed lockIndex, uint amountLocked, uint interestEarned,\n                    uint lockedUntil, uint perTermInterest, uint durationInSecs, bool isActive);\n\n    event LockReleased(address indexed lockOwner, uint indexed lockIndex);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint perTermInterest;\n        uint durationInSecs;\n        uint minimumLockAmount;\n        bool isActive;\n    }\n\n    struct Lock {\n        uint amountLocked;\n        uint interestEarned;\n        uint lockedUntil;\n        uint perTermInterest;\n        uint durationInSecs;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n    // per account locks (i.e. an id for a lock is a tuple (owner, index)):\n    mapping(address => Lock[]) public locks;\n\n    function Locker(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint perTermInterest, uint durationInSecs, uint minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n\n        require(lockProductId < lockProducts.length);\n        lockProducts[lockProductId].isActive = isActive;\n        LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    function releaseFunds(address lockOwner, uint lockIndex) external {\n\n        Lock storage lock = locks[lockOwner][lockIndex];\n\n        require(lock.isActive && now >= lock.lockedUntil);\n\n        lock.isActive = false;\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked);   // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lockOwner, lock.amountLocked.add(lock.interestEarned),\n                                                                                \"Funds released from lock\");\n\n        LockReleased(lockOwner, lockIndex);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[4][20]) {\n\n        uint[4][20] memory response;\n\n        for (uint8 i = 0; i < 20; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs,\n                                        lockProduct.minimumLockAmount, lockProduct.isActive ? 1 : 0 ];\n\n        }\n\n        return response;\n\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n\n        return locks[lockOwner].length;\n\n    }\n\n    // returns 20 locks starting from some offset\n    // lock products are encoded as\n    //              [amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[6][20]) {\n\n        Lock[] storage locksForAddress = locks[lockOwner];\n        uint[6][20] memory response;\n\n        for (uint8 i = 0; i < 20; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locksForAddress[offset + i];\n\n            response[i] = [ lock.amountLocked, lock.interestEarned, lock.lockedUntil, lock.perTermInterest,\n                                        lock.durationInSecs, lock.isActive ? 1 : 0 ];\n\n        }\n\n        return response;\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint lockProductId) public {\n        require(msg.sender == address(augmintToken));\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function calculateInterestForLockProduct(uint lockProductId, uint amountToLock) public view returns (uint) {\n\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive);\n        require(amountToLock >= lockProduct.minimumLockAmount);\n\n        uint interestEarned = amountToLock.mul(lockProduct.perTermInterest).div(1000000);\n\n        return interestEarned;\n\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint lockProductId, address lockOwner, uint amountToLock) internal returns (uint) {\n\n        // NB: calculateInterestForLockProduct will validate the lock product and amountToLock:\n        uint interestEarned = calculateInterestForLockProduct(lockProductId, amountToLock);\n\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n\n        uint lockedUntil = now.add(lockProduct.durationInSecs);\n        uint lockIndex = locks[lockOwner].push(Lock(amountToLock, interestEarned, lockedUntil,\n                                                    lockProduct.perTermInterest, lockProduct.durationInSecs, true)) - 1;\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        NewLock(lockOwner, lockIndex, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs, true);\n\n        return interestEarned;\n    }\n\n}\n"
      }
    }
  }
}