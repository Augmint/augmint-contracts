{
  "contractName": "Locker",
  "latestAbiHash": "f59526398823aef0f0c1454d0b6b4eac",
  "deployedAbis": {
    "f59526398823aef0f0c1454d0b6b4eac": {
      "latestDeployedAddress": "0x6d84ab6c385b827e58c358d078ac7b1c61b68821",
      "deployments": {
        "0x6d84ab6c385b827e58c358d078ac7b1c61b68821": {
          "generatedAt": "2018-10-18T13:35:02.423Z",
          "truffleContractFileUpdatedAt": "2018-10-18T11:36:36.960Z",
          "deployTransactionHash": "0x2d7780b0e0947b2b96a2d3d14bdcec5d6045d619cdd8a94dccfc43e0b36c287a",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "0fe102ad0cf754658fdb075cb2850270",
          "deployedBytecodeHash": "211e0b56eb9155bf091df2937a90551d",
          "sourceHash": "5fb19771489eecebfa02e95214887146",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity 0.4.24;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                    uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"StabilityBoard\") {\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"StabilityBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(_lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"StabilityBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n        return lockProducts.length;\n    }\n\n    // returns <chunkSize> lock products starting from some <offset>\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset, uint16 chunkSize)\n    external view returns (uint[5][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), lockProducts.length);\n        uint[5][] memory response = new uint[5][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            LockProduct storage lockProduct = lockProducts[i];\n            response[i - offset] = [lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns <chunkSize> locks starting from some <offset>\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset, uint16 chunkSize)\n    external view returns (uint[8][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), locks.length);\n        uint[8][] memory response = new uint[8][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            Lock storage lock = locks[i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i - offset] = [uint(i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                        lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n        return response;\n    }\n\n    // returns <chunkSize> locks of a given account, starting from some <offset>\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset, uint16 chunkSize)\n    external view returns (uint[7][]) {\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n        uint limit = SafeMath.min(offset.add(chunkSize), locksForAddress.length);\n        uint[7][] memory response = new uint[7][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            Lock storage lock = locks[locksForAddress[i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i - offset] = [locksForAddress[i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                        lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).ceilDiv(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        uint lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n}\n"
        }
      }
    }
  }
}