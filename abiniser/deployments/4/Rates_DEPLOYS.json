{
  "contractName": "Rates",
  "latestAbiHash": "73a17ebb0acc71773371c6a8e1c8e6ce",
  "deployedAbis": {
    "73a17ebb0acc71773371c6a8e1c8e6ce": {
      "latestDeployedAddress": "0xee8c7a3e99945a5207dca026504d67527125da9c",
      "deployments": {
        "0xdfa3a0aeb9645a55b684cb3ace8c42d018405bda": {
          "generatedAt": "2018-10-18T13:35:02.334Z",
          "truffleContractFileUpdatedAt": "2018-10-18T11:36:36.909Z",
          "deployTransactionHash": "0xcdfc636cb95b245a8e7fb30a8d5a2be26fc2f781f73cd0ef33d82f271b684613",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "be17116585b9b88d60fbe06a5499b6dc",
          "deployedBytecodeHash": "0f403183577dac202159e32b1c8c9f44",
          "sourceHash": "c65f6945fead6118910fccc8bca7494c",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 2 decimals. i.e. EUR/ETH = 989.12 then rate = 98912\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"RatesFeeder\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"RatesFeeder\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        },
        "0xee8c7a3e99945a5207dca026504d67527125da9c": {
          "generatedAt": "2018-10-29T15:52:43.242Z",
          "truffleContractFileUpdatedAt": "2018-10-19T15:49:10.755Z",
          "deployTransactionHash": "0x300a82bb283510c9a429d6ce81e22586f0c42c9caf9445633a72e2424968967f",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "be17116585b9b88d60fbe06a5499b6dc",
          "deployedBytecodeHash": "0f403183577dac202159e32b1c8c9f44",
          "sourceHash": "c65f6945fead6118910fccc8bca7494c",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 2 decimals. i.e. EUR/ETH = 989.12 then rate = 98912\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"RatesFeeder\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"RatesFeeder\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        }
      }
    }
  }
}