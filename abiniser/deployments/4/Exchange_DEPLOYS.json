{
  "contractName": "Exchange",
  "latestAbiHash": "d3e7f8a261b756f9c40da097608b21cd",
  "deployedAbis": {
    "d3e7f8a261b756f9c40da097608b21cd": {
      "latestDeployedAddress": "0xe5d6d0c107eae79d2d30798f252ac6ff5ecad459",
      "deployments": {
        "0xdf47d51028daff13424f42523fdac73079ab901b": {
          "generatedAt": "2018-10-18T13:35:02.438Z",
          "truffleContractFileUpdatedAt": "2018-10-18T11:36:36.980Z",
          "deployTransactionHash": "0x35b0caa7f3479a08e88a8554eb6ffea246c5364e89969941a21a095cede76c65",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "5a731d45c1595b7ffeb40bae693ef88d",
          "deployedBytecodeHash": "136e48f6880df5153792c846d87ddede",
          "sourceHash": "d6ff57acb1b45199b5dd08357978d8c2",
          "source": "/* Augmint's Internal Exchange\n\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n\n    TODO:\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n        - deduct fee\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n        - use Rates interface?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./Rates.sol\";\n\n\ncontract Exchange is Restricted {\n    using SafeMath for uint256;\n\n    AugmintTokenInterface public augmintToken;\n    Rates public rates;\n\n    struct Order {\n        uint64 index;\n        address maker;\n\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n        uint32 price;\n\n        // buy order: amount in wei\n        // sell order: token amount\n        uint amount;\n    }\n\n    uint64 public orderCount;\n    mapping(uint64 => Order) public buyTokenOrders;\n    mapping(uint64 => Order) public sellTokenOrders;\n\n    uint64[] private activeBuyOrders;\n    uint64[] private activeSellOrders;\n\n    /* used to stop executing matchMultiple when running out of gas.\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint weiAmount, uint tokenAmount);\n\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n\n    event RatesContractChanged(Rates newRatesContract);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        rates = _rates;\n    }\n\n    /* to allow upgrade of Rates  contract */\n    function setRatesContract(Rates newRatesContract)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        emit RatesContractChanged(newRatesContract);\n    }\n\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(msg.value > 0, \"msg.value must be > 0\");\n\n        orderId = ++orderCount;\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n        activeBuyOrders.push(orderId);\n\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n    }\n\n    /* this function requires previous approval to transfer tokens */\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n    }\n\n    /* place sell token order called from AugmintToken's transferAndNotify\n     Flow:\n        1) user calls token contract's transferAndNotify price passed in data arg\n        2) transferAndNotify transfers tokens to the Exchange contract\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n    */\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n    }\n\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n        Order storage order = buyTokenOrders[buyTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"buy order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeBuyOrder(order);\n\n        msg.sender.transfer(amount);\n\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n    }\n\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\n        Order storage order = sellTokenOrders[sellTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"sell order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeSellOrder(order);\n\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\n\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n    }\n\n    /* matches any two orders if the sell price >= buy price\n        trade price is the price of the maker (the order placed earlier)\n        reverts if any of the orders have been removed\n    */\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\n    }\n\n    /*  matches as many orders as possible from the passed orders\n        Runs as long as gas is available for the call.\n        Reverts if any match is invalid (e.g sell price > buy price)\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n    */\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n        uint len = buyTokenIds.length;\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\n\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n                matchCount++;\n            }\n        }\n    }\n\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n        return(activeBuyOrders.length, activeSellOrders.length);\n    }\n\n    // returns <chunkSize> active buy orders starting from <offset>\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveBuyOrders(uint offset, uint16 chunkSize)\n    external view returns (uint[4][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), activeBuyOrders.length);\n        uint[4][] memory response = new uint[4][](limit.sub(offset));\n        for (uint i = offset; i < limit; i++) {\n            uint64 orderId = activeBuyOrders[i];\n            Order storage order = buyTokenOrders[orderId];\n            response[i - offset] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n        return response;\n    }\n\n    // returns <chunkSize> active sell orders starting from <offset>\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveSellOrders(uint offset, uint16 chunkSize)\n    external view returns (uint[4][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), activeSellOrders.length);\n        uint[4][] memory response = new uint[4][](limit.sub(offset));\n        for (uint i = offset; i < limit; i++) {\n            uint64 orderId = activeSellOrders[i];\n            Order storage order = sellTokenOrders[orderId];\n            response[i - offset] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n        return response;\n    }\n\n    uint private constant E12 = 1000000000000;\n\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n        Order storage buy = buyTokenOrders[buyTokenId];\n        Order storage sell = sellTokenOrders[sellTokenId];\n        if( buy.amount == 0 || sell.amount == 0 ) {\n            return false; // one order is already filled and removed.\n                          // we let matchMultiple continue, indivudal match will revert\n        }\n\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\n\n        // pick maker's price (whoever placed order sooner considered as maker)\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n\n        uint publishedRate;\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n        // fillRate = publishedRate * 1000000 / price\n\n        uint sellWei = sell.amount.mul(uint(price)).mul(E12).roundedDiv(publishedRate);\n\n        uint tradedWei;\n        uint tradedTokens;\n        if (sellWei <= buy.amount) {\n            tradedWei = sellWei;\n            tradedTokens = sell.amount;\n        } else {\n            tradedWei = buy.amount;\n            tradedTokens = buy.amount.mul(publishedRate).roundedDiv(uint(price).mul(E12));\n        }\n\n        buy.amount = buy.amount.sub(tradedWei);\n        if (buy.amount == 0) {\n            _removeBuyOrder(buy);\n        }\n\n        sell.amount = sell.amount.sub(tradedTokens);\n        if (sell.amount == 0) {\n            _removeSellOrder(sell);\n        }\n\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\n        sell.maker.transfer(tradedWei);\n\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n            sellTokenId, publishedRate, price, tradedWei, tradedTokens);\n\n        return true;\n    }\n\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n    private returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\n\n        orderId = ++orderCount;\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n        activeSellOrders.push(orderId);\n\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n    }\n\n    function _removeBuyOrder(Order storage order) private {\n        uint lastIndex = activeBuyOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeBuyOrders[lastIndex];\n            activeBuyOrders[order.index] = movedOrderId;\n            buyTokenOrders[movedOrderId].index = order.index;\n        }\n        activeBuyOrders.length--;\n    }\n\n    function _removeSellOrder(Order storage order) private {\n        uint lastIndex = activeSellOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeSellOrders[lastIndex];\n            activeSellOrders[order.index] = movedOrderId;\n            sellTokenOrders[movedOrderId].index = order.index;\n        }\n        activeSellOrders.length--;\n    }\n}\n"
        },
        "0xe5d6d0c107eae79d2d30798f252ac6ff5ecad459": {
          "generatedAt": "2018-10-29T15:52:43.331Z",
          "truffleContractFileUpdatedAt": "2018-10-19T15:49:10.813Z",
          "deployTransactionHash": "0x1823548271afb6df6cb6012027d2c32f3c7d649056be0e12a5698e35c2ed1fe1",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "5a731d45c1595b7ffeb40bae693ef88d",
          "deployedBytecodeHash": "136e48f6880df5153792c846d87ddede",
          "sourceHash": "d6ff57acb1b45199b5dd08357978d8c2",
          "source": "/* Augmint's Internal Exchange\n\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n\n    TODO:\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n        - deduct fee\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n        - use Rates interface?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./Rates.sol\";\n\n\ncontract Exchange is Restricted {\n    using SafeMath for uint256;\n\n    AugmintTokenInterface public augmintToken;\n    Rates public rates;\n\n    struct Order {\n        uint64 index;\n        address maker;\n\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n        uint32 price;\n\n        // buy order: amount in wei\n        // sell order: token amount\n        uint amount;\n    }\n\n    uint64 public orderCount;\n    mapping(uint64 => Order) public buyTokenOrders;\n    mapping(uint64 => Order) public sellTokenOrders;\n\n    uint64[] private activeBuyOrders;\n    uint64[] private activeSellOrders;\n\n    /* used to stop executing matchMultiple when running out of gas.\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint weiAmount, uint tokenAmount);\n\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n\n    event RatesContractChanged(Rates newRatesContract);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        rates = _rates;\n    }\n\n    /* to allow upgrade of Rates  contract */\n    function setRatesContract(Rates newRatesContract)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        emit RatesContractChanged(newRatesContract);\n    }\n\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(msg.value > 0, \"msg.value must be > 0\");\n\n        orderId = ++orderCount;\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n        activeBuyOrders.push(orderId);\n\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n    }\n\n    /* this function requires previous approval to transfer tokens */\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n    }\n\n    /* place sell token order called from AugmintToken's transferAndNotify\n     Flow:\n        1) user calls token contract's transferAndNotify price passed in data arg\n        2) transferAndNotify transfers tokens to the Exchange contract\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n    */\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n    }\n\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n        Order storage order = buyTokenOrders[buyTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"buy order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeBuyOrder(order);\n\n        msg.sender.transfer(amount);\n\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n    }\n\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\n        Order storage order = sellTokenOrders[sellTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"sell order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeSellOrder(order);\n\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\n\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n    }\n\n    /* matches any two orders if the sell price >= buy price\n        trade price is the price of the maker (the order placed earlier)\n        reverts if any of the orders have been removed\n    */\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\n    }\n\n    /*  matches as many orders as possible from the passed orders\n        Runs as long as gas is available for the call.\n        Reverts if any match is invalid (e.g sell price > buy price)\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n    */\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n        uint len = buyTokenIds.length;\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\n\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n                matchCount++;\n            }\n        }\n    }\n\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n        return(activeBuyOrders.length, activeSellOrders.length);\n    }\n\n    // returns <chunkSize> active buy orders starting from <offset>\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveBuyOrders(uint offset, uint16 chunkSize)\n    external view returns (uint[4][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), activeBuyOrders.length);\n        uint[4][] memory response = new uint[4][](limit.sub(offset));\n        for (uint i = offset; i < limit; i++) {\n            uint64 orderId = activeBuyOrders[i];\n            Order storage order = buyTokenOrders[orderId];\n            response[i - offset] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n        return response;\n    }\n\n    // returns <chunkSize> active sell orders starting from <offset>\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveSellOrders(uint offset, uint16 chunkSize)\n    external view returns (uint[4][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), activeSellOrders.length);\n        uint[4][] memory response = new uint[4][](limit.sub(offset));\n        for (uint i = offset; i < limit; i++) {\n            uint64 orderId = activeSellOrders[i];\n            Order storage order = sellTokenOrders[orderId];\n            response[i - offset] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n        return response;\n    }\n\n    uint private constant E12 = 1000000000000;\n\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n        Order storage buy = buyTokenOrders[buyTokenId];\n        Order storage sell = sellTokenOrders[sellTokenId];\n        if( buy.amount == 0 || sell.amount == 0 ) {\n            return false; // one order is already filled and removed.\n                          // we let matchMultiple continue, indivudal match will revert\n        }\n\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\n\n        // pick maker's price (whoever placed order sooner considered as maker)\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n\n        uint publishedRate;\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n        // fillRate = publishedRate * 1000000 / price\n\n        uint sellWei = sell.amount.mul(uint(price)).mul(E12).roundedDiv(publishedRate);\n\n        uint tradedWei;\n        uint tradedTokens;\n        if (sellWei <= buy.amount) {\n            tradedWei = sellWei;\n            tradedTokens = sell.amount;\n        } else {\n            tradedWei = buy.amount;\n            tradedTokens = buy.amount.mul(publishedRate).roundedDiv(uint(price).mul(E12));\n        }\n\n        buy.amount = buy.amount.sub(tradedWei);\n        if (buy.amount == 0) {\n            _removeBuyOrder(buy);\n        }\n\n        sell.amount = sell.amount.sub(tradedTokens);\n        if (sell.amount == 0) {\n            _removeSellOrder(sell);\n        }\n\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\n        sell.maker.transfer(tradedWei);\n\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n            sellTokenId, publishedRate, price, tradedWei, tradedTokens);\n\n        return true;\n    }\n\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n    private returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\n\n        orderId = ++orderCount;\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n        activeSellOrders.push(orderId);\n\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n    }\n\n    function _removeBuyOrder(Order storage order) private {\n        uint lastIndex = activeBuyOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeBuyOrders[lastIndex];\n            activeBuyOrders[order.index] = movedOrderId;\n            buyTokenOrders[movedOrderId].index = order.index;\n        }\n        activeBuyOrders.length--;\n    }\n\n    function _removeSellOrder(Order storage order) private {\n        uint lastIndex = activeSellOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeSellOrders[lastIndex];\n            activeSellOrders[order.index] = movedOrderId;\n            sellTokenOrders[movedOrderId].index = order.index;\n        }\n        activeSellOrders.length--;\n    }\n}\n"
        }
      }
    }
  }
}