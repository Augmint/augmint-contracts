{
  "contractName": "LoanManager",
  "latestAbiHash": "fdf5fde95aa940c6dbfb8353c572c5fb",
  "deployedAbis": {
    "fdf5fde95aa940c6dbfb8353c572c5fb": {
      "latestDeployedAddress": "0x3792c5a5077dacfe331b81837ef73bc0ea721d90",
      "deployments": {
        "0x6cb7731c78e677f85942b5f1d646b3485e5820c1": {
          "generatedAt": "2018-10-18T13:35:02.404Z",
          "truffleContractFileUpdatedAt": "2018-10-18T11:36:37.002Z",
          "deployTransactionHash": "0xc965162409524ff0b21cebe1a763229400994d88856dfdd766398a47f0d6493f",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "591f565c201032e0df4b9f7798e7ec85",
          "deployedBytecodeHash": "e93edcccad1eb8f9142f6c257bb23bdd",
          "sourceHash": "234fd5848af85ca2444c888fd6ba61aa",
          "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity 0.4.24;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted, TokenReceiver {\n    using SafeMath for uint256;\n\n    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n\n    struct LoanProduct {\n        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n        uint32 term;            // 1\n        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n                                //      in parts per million , ie. 10,000 = 1%\n        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive;          // 5\n    }\n\n    /* NB: we don't need to store loan parameters because loan products can't be altered (only disabled/enabled) */\n    struct LoanData {\n        uint collateralAmount; // 0\n        uint repaymentAmount; // 1\n        address borrower; // 2\n        uint32 productId; // 3\n        LoanState state; // 4\n        uint40 maturity; // 5\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n\n    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount, uint40 maturity);\n\n    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n\n    event LoanProductAdded(uint32 productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    event SystemContractsChanged(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n    }\n\n    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n                                uint32 defaultingFeePt, bool isActive)\n    external restrict(\"StabilityBoard\") {\n\n        uint _newProductId = products.push(\n            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n        ) - 1;\n\n        uint32 newProductId = uint32(_newProductId);\n        require(newProductId == _newProductId, \"productId overflow\");\n\n        emit LoanProductAdded(newProductId);\n    }\n\n    function setLoanProductActiveState(uint32 productId, bool newState)\n    external restrict (\"StabilityBoard\") {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        products[productId].isActive = newState;\n        emit LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint32 productId) external payable {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        LoanProduct storage product = products[productId];\n        require(product.isActive, \"product must be in active state\"); // valid product\n\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n\n        uint loanAmount;\n        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n\n        require(loanAmount >= product.minDisbursedAmount, \"loanAmount must be >= minDisbursedAmount\");\n\n        uint expiration = now.add(product.term);\n        uint40 maturity = uint40(expiration);\n        require(maturity == expiration, \"maturity overflow\");\n\n        // Create new loan\n        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n                                            productId, LoanState.Open, maturity)) - 1;\n\n        // Store ref to new loan\n        accountLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        emit NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        uint totalDefaultingFee;\n        for (uint i = 0; i < loanIds.length; i++) {\n            require(loanIds[i] < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n            LoanData storage loan = loans[loanIds[i]];\n            require(loan.state == LoanState.Open, \"loan state must be Open\");\n            require(now >= loan.maturity, \"current time must be later than maturity\");\n            LoanProduct storage product = products[loan.productId];\n\n            uint loanAmount;\n            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n\n            loan.state = LoanState.Collected;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n                    loan.repaymentAmount).add(defaultingFee);\n\n            uint releasedCollateral;\n            if (targetCollection < loan.collateralAmount) {\n                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n                loan.borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n            if (defaultingFee >= collateralToCollect) {\n                defaultingFee = collateralToCollect;\n                collateralToCollect = 0;\n            } else {\n                collateralToCollect = collateralToCollect.sub(defaultingFee);\n            }\n            totalDefaultingFee = totalDefaultingFee.add(defaultingFee);\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            emit LoanCollected(loanIds[i], loan.borrower, collateralToCollect.add(defaultingFee),\n                    releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            address(monetarySupervisor.augmintReserves()).transfer(totalCollateralToCollect);\n        }\n\n        if (totalDefaultingFee > 0) {\n            address(augmintToken.feeAccount()).transfer(totalDefaultingFee);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    /* to allow upgrade of Rates and MonetarySupervisor contracts */\n    function setSystemContracts(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        monetarySupervisor = newMonetarySupervisor;\n        emit SystemContractsChanged(newRatesContract, newMonetarySupervisor);\n    }\n\n    function getProductCount() external view returns (uint) {\n        return products.length;\n    }\n\n    // returns <chunkSize> loan products starting from some <offset>:\n    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, maxLoanAmount, isActive ]\n    function getProducts(uint offset, uint16 chunkSize)\n    external view returns (uint[8][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), products.length);\n        uint[8][] memory response = new uint[8][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            LoanProduct storage product = products[i];\n            response[i - offset] = [i, product.minDisbursedAmount, product.term, product.discountRate,\n                    product.collateralRatio, product.defaultingFeePt,\n                    monetarySupervisor.getMaxLoanAmount(product.minDisbursedAmount), product.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function getLoanCount() external view returns (uint) {\n        return loans.length;\n    }\n\n    /* returns <chunkSize> loans starting from some <offset>. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId,\n              state, maturity, disbursementTime, loanAmount, interestAmount] */\n    function getLoans(uint offset, uint16 chunkSize)\n    external view returns (uint[10][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), loans.length);\n        uint[10][] memory response = new uint[10][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            response[i - offset] = getLoanTuple(i);\n        }\n        return response;\n    }\n\n    function getLoanCountForAddress(address borrower) external view returns (uint) {\n        return accountLoans[borrower].length;\n    }\n\n    /* returns <chunkSize> loans of a given account, starting from some <offset>. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ] */\n    function getLoansForAddress(address borrower, uint offset, uint16 chunkSize)\n    external view returns (uint[10][]) {\n        uint[] storage loansForAddress = accountLoans[borrower];\n        uint limit = SafeMath.min(offset.add(chunkSize), loansForAddress.length);\n        uint[10][] memory response = new uint[10][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            response[i - offset] = getLoanTuple(loansForAddress[i]);\n        }\n        return response;\n    }\n\n    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        LoanProduct storage product = products[loan.productId];\n\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n        uint disbursementTime = loan.maturity - product.term;\n\n        LoanState loanState =\n                loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n\n        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n                loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n    }\n\n    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n    internal view returns (uint loanAmount, uint interestAmount) {\n        // calculate loan values based on repayment amount\n        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        require(loan.state == LoanState.Open, \"loan state must be Open\");\n        require(repaymentAmount == loan.repaymentAmount, \"repaymentAmount must be equal to tokens sent\");\n        require(now <= loan.maturity, \"current time must be earlier than maturity\");\n\n        LoanProduct storage product = products[loan.productId];\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n\n        loans[loanId].state = LoanState.Repaid;\n\n        if (interestAmount > 0) {\n            augmintToken.transfer(monetarySupervisor.interestEarnedAccount(), interestAmount);\n            augmintToken.burn(loanAmount);\n        } else {\n            // negative or zero interest (i.e. discountRate >= 0)\n            augmintToken.burn(repaymentAmount);\n        }\n\n        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n\n        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n\n        emit LoanRepayed(loanId, loan.borrower);\n    }\n}\n"
        },
        "0x3792c5a5077dacfe331b81837ef73bc0ea721d90": {
          "generatedAt": "2018-10-29T15:52:43.304Z",
          "truffleContractFileUpdatedAt": "2018-10-19T15:49:10.833Z",
          "deployTransactionHash": "0x5539b5879aacf2739d48f457fcd22a70d74d12af2512a7770ab3d9558cc587d7",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "591f565c201032e0df4b9f7798e7ec85",
          "deployedBytecodeHash": "e93edcccad1eb8f9142f6c257bb23bdd",
          "sourceHash": "234fd5848af85ca2444c888fd6ba61aa",
          "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity 0.4.24;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted, TokenReceiver {\n    using SafeMath for uint256;\n\n    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n\n    struct LoanProduct {\n        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n        uint32 term;            // 1\n        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n                                //      in parts per million , ie. 10,000 = 1%\n        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive;          // 5\n    }\n\n    /* NB: we don't need to store loan parameters because loan products can't be altered (only disabled/enabled) */\n    struct LoanData {\n        uint collateralAmount; // 0\n        uint repaymentAmount; // 1\n        address borrower; // 2\n        uint32 productId; // 3\n        LoanState state; // 4\n        uint40 maturity; // 5\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n\n    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount, uint40 maturity);\n\n    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n\n    event LoanProductAdded(uint32 productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    event SystemContractsChanged(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n    }\n\n    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n                                uint32 defaultingFeePt, bool isActive)\n    external restrict(\"StabilityBoard\") {\n\n        uint _newProductId = products.push(\n            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n        ) - 1;\n\n        uint32 newProductId = uint32(_newProductId);\n        require(newProductId == _newProductId, \"productId overflow\");\n\n        emit LoanProductAdded(newProductId);\n    }\n\n    function setLoanProductActiveState(uint32 productId, bool newState)\n    external restrict (\"StabilityBoard\") {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        products[productId].isActive = newState;\n        emit LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint32 productId) external payable {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        LoanProduct storage product = products[productId];\n        require(product.isActive, \"product must be in active state\"); // valid product\n\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n\n        uint loanAmount;\n        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n\n        require(loanAmount >= product.minDisbursedAmount, \"loanAmount must be >= minDisbursedAmount\");\n\n        uint expiration = now.add(product.term);\n        uint40 maturity = uint40(expiration);\n        require(maturity == expiration, \"maturity overflow\");\n\n        // Create new loan\n        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n                                            productId, LoanState.Open, maturity)) - 1;\n\n        // Store ref to new loan\n        accountLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        emit NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        uint totalDefaultingFee;\n        for (uint i = 0; i < loanIds.length; i++) {\n            require(loanIds[i] < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n            LoanData storage loan = loans[loanIds[i]];\n            require(loan.state == LoanState.Open, \"loan state must be Open\");\n            require(now >= loan.maturity, \"current time must be later than maturity\");\n            LoanProduct storage product = products[loan.productId];\n\n            uint loanAmount;\n            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n\n            loan.state = LoanState.Collected;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n                    loan.repaymentAmount).add(defaultingFee);\n\n            uint releasedCollateral;\n            if (targetCollection < loan.collateralAmount) {\n                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n                loan.borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n            if (defaultingFee >= collateralToCollect) {\n                defaultingFee = collateralToCollect;\n                collateralToCollect = 0;\n            } else {\n                collateralToCollect = collateralToCollect.sub(defaultingFee);\n            }\n            totalDefaultingFee = totalDefaultingFee.add(defaultingFee);\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            emit LoanCollected(loanIds[i], loan.borrower, collateralToCollect.add(defaultingFee),\n                    releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            address(monetarySupervisor.augmintReserves()).transfer(totalCollateralToCollect);\n        }\n\n        if (totalDefaultingFee > 0) {\n            address(augmintToken.feeAccount()).transfer(totalDefaultingFee);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    /* to allow upgrade of Rates and MonetarySupervisor contracts */\n    function setSystemContracts(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        monetarySupervisor = newMonetarySupervisor;\n        emit SystemContractsChanged(newRatesContract, newMonetarySupervisor);\n    }\n\n    function getProductCount() external view returns (uint) {\n        return products.length;\n    }\n\n    // returns <chunkSize> loan products starting from some <offset>:\n    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, maxLoanAmount, isActive ]\n    function getProducts(uint offset, uint16 chunkSize)\n    external view returns (uint[8][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), products.length);\n        uint[8][] memory response = new uint[8][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            LoanProduct storage product = products[i];\n            response[i - offset] = [i, product.minDisbursedAmount, product.term, product.discountRate,\n                    product.collateralRatio, product.defaultingFeePt,\n                    monetarySupervisor.getMaxLoanAmount(product.minDisbursedAmount), product.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function getLoanCount() external view returns (uint) {\n        return loans.length;\n    }\n\n    /* returns <chunkSize> loans starting from some <offset>. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId,\n              state, maturity, disbursementTime, loanAmount, interestAmount] */\n    function getLoans(uint offset, uint16 chunkSize)\n    external view returns (uint[10][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), loans.length);\n        uint[10][] memory response = new uint[10][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            response[i - offset] = getLoanTuple(i);\n        }\n        return response;\n    }\n\n    function getLoanCountForAddress(address borrower) external view returns (uint) {\n        return accountLoans[borrower].length;\n    }\n\n    /* returns <chunkSize> loans of a given account, starting from some <offset>. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ] */\n    function getLoansForAddress(address borrower, uint offset, uint16 chunkSize)\n    external view returns (uint[10][]) {\n        uint[] storage loansForAddress = accountLoans[borrower];\n        uint limit = SafeMath.min(offset.add(chunkSize), loansForAddress.length);\n        uint[10][] memory response = new uint[10][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            response[i - offset] = getLoanTuple(loansForAddress[i]);\n        }\n        return response;\n    }\n\n    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        LoanProduct storage product = products[loan.productId];\n\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n        uint disbursementTime = loan.maturity - product.term;\n\n        LoanState loanState =\n                loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n\n        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n                loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n    }\n\n    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n    internal view returns (uint loanAmount, uint interestAmount) {\n        // calculate loan values based on repayment amount\n        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        require(loan.state == LoanState.Open, \"loan state must be Open\");\n        require(repaymentAmount == loan.repaymentAmount, \"repaymentAmount must be equal to tokens sent\");\n        require(now <= loan.maturity, \"current time must be earlier than maturity\");\n\n        LoanProduct storage product = products[loan.productId];\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n\n        loans[loanId].state = LoanState.Repaid;\n\n        if (interestAmount > 0) {\n            augmintToken.transfer(monetarySupervisor.interestEarnedAccount(), interestAmount);\n            augmintToken.burn(loanAmount);\n        } else {\n            // negative or zero interest (i.e. discountRate >= 0)\n            augmintToken.burn(repaymentAmount);\n        }\n\n        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n\n        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n\n        emit LoanRepayed(loanId, loan.borrower);\n    }\n}\n"
        }
      }
    }
  }
}