{
  "contractName": "Rates",
  "latestAbiHash": "73a17ebb0acc71773371c6a8e1c8e6ce",
  "deployedAbis": {
    "73a17ebb0acc71773371c6a8e1c8e6ce": {
      "latestDeployedAddress": "0x4272dB2EB82068E898588C3D6e4B5D55c3848793",
      "deployments": {
        "0x4babbe57453e2b6af125b4e304256fcbdf744480": {
          "generatedAt": "2018-06-11T12:15:16.443Z",
          "truffleContractFileUpdatedAt": "2018-06-11T11:56:49.360Z",
          "deployTransactionHash": "0x76efaa8491bd5622a2e328f812cb99c5c72236b663ac594edd94893b45596492",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "b2bf3f97147e9144c7103442be20e58a",
          "deployedBytecodeHash": "6a3a4ec8c050710692adaa9f97d09bb6",
          "sourceHash": "d71ec203e7ee6ed376feeb17e5df7966",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"RatesFeeder\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"RatesFeeder\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        },
        "0x4272dB2EB82068E898588C3D6e4B5D55c3848793": {
          "generatedAt": "2018-11-14T12:52:13.016Z",
          "truffleContractFileUpdatedAt": "2018-11-13T16:34:24.490Z",
          "deployTransactionHash": "0x3a0ca0223275fc414b93f60548060dc1e4329deaaa14b46460a9ca28bfc322ea",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "be17116585b9b88d60fbe06a5499b6dc",
          "deployedBytecodeHash": "0f403183577dac202159e32b1c8c9f44",
          "sourceHash": "c65f6945fead6118910fccc8bca7494c",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 2 decimals. i.e. EUR/ETH = 989.12 then rate = 98912\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"RatesFeeder\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"RatesFeeder\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        }
      }
    }
  }
}