{
  "contractName": "Exchange",
  "latestAbiHash": "b2a23202a9a0f04755a186896c2b56eb",
  "deployedAbis": {
    "b2a23202a9a0f04755a186896c2b56eb": {
      "latestDeployedAddress": "0x8b52b019d237d0bbe8baedf219132d5254e0690b",
      "deployments": {
        "0x8b52b019d237d0bbe8baedf219132d5254e0690b": {
          "generatedAt": "2018-06-11T14:59:44.035Z",
          "truffleContractFileUpdatedAt": "2018-06-11T14:55:55.596Z",
          "deployTransactionHash": "0x6e94d5201dc67810d50210f26464fe6ffa74454b8f2663809db37b01830070d5",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "09662358eb649fe02860d3f98722ee64",
          "deployedBytecodeHash": "5dc02051446dcb33dceff75a1635ea27",
          "sourceHash": "7a417a79bd6036b0b1b796d00bc176ca",
          "source": "/* Augmint's Internal Exchange\n\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n\n    TODO:\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n        - deduct fee\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n        - use Rates interface?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./Rates.sol\";\n\n\ncontract Exchange is Restricted {\n    using SafeMath for uint256;\n\n    AugmintTokenInterface public augmintToken;\n    Rates public rates;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    struct Order {\n        uint64 index;\n        address maker;\n\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n        uint32 price;\n\n        // buy order: amount in wei\n        // sell order: token amount\n        uint amount;\n    }\n\n    uint64 public orderCount;\n    mapping(uint64 => Order) public buyTokenOrders;\n    mapping(uint64 => Order) public sellTokenOrders;\n\n    uint64[] private activeBuyOrders;\n    uint64[] private activeSellOrders;\n\n    /* used to stop executing matchMultiple when running out of gas.\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint fillRate, uint weiAmount, uint tokenAmount);\n\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n\n    event RatesContractChanged(Rates newRatesContract);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        rates = _rates;\n    }\n\n    /* to allow upgrade of Rates  contract */\n    function setRatesContract(Rates newRatesContract)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        emit RatesContractChanged(newRatesContract);\n    }\n\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(msg.value > 0, \"msg.value must be > 0\");\n\n        orderId = ++orderCount;\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n        activeBuyOrders.push(orderId);\n\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n    }\n\n    /* this function requires previous approval to transfer tokens */\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n    }\n\n    /* place sell token order called from AugmintToken's transferAndNotify\n     Flow:\n        1) user calls token contract's transferAndNotify price passed in data arg\n        2) transferAndNotify transfers tokens to the Exchange contract\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n    */\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n    }\n\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n        Order storage order = buyTokenOrders[buyTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"buy order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeBuyOrder(order);\n\n        msg.sender.transfer(amount);\n\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n    }\n\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\n        Order storage order = sellTokenOrders[sellTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"sell order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeSellOrder(order);\n\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\n\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n    }\n\n    /* matches any two orders if the sell price >= buy price\n        trade price is the price of the maker (the order placed earlier)\n        reverts if any of the orders have been removed\n    */\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\n    }\n\n    /*  matches as many orders as possible from the passed orders\n        Runs as long as gas is available for the call.\n        Reverts if any match is invalid (e.g sell price > buy price)\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n    */\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n        uint len = buyTokenIds.length;\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\n\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n                matchCount++;\n            }\n        }\n    }\n\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n        return(activeBuyOrders.length, activeSellOrders.length);\n    }\n\n    // returns CHUNK_SIZE orders starting from offset\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveBuyOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeBuyOrders.length; i++) {\n            uint64 orderId = activeBuyOrders[offset + i];\n            Order storage order = buyTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    function getActiveSellOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeSellOrders.length; i++) {\n            uint64 orderId = activeSellOrders[offset + i];\n            Order storage order = sellTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n        Order storage buy = buyTokenOrders[buyTokenId];\n        Order storage sell = sellTokenOrders[sellTokenId];\n        if( buy.amount == 0 || sell.amount == 0 ) {\n            return false; // one order is already filled and removed.\n                          // we let matchMultiple continue, indivudal match will revert\n        }\n\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\n\n        // pick maker's price (whoever placed order sooner considered as maker)\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n\n        uint publishedRate;\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n        uint fillRate = publishedRate.mul(price).roundedDiv(1000000);\n\n        uint sellWei = sell.amount.mul(1 ether).roundedDiv(fillRate);\n\n        uint tradedWei;\n        uint tradedTokens;\n        if (sellWei <= buy.amount) {\n            tradedWei = sellWei;\n            tradedTokens = sell.amount;\n        } else {\n            tradedWei = buy.amount;\n            tradedTokens = buy.amount.mul(fillRate).roundedDiv(1 ether);\n        }\n\n        buy.amount = buy.amount.sub(tradedWei);\n        if (buy.amount == 0) {\n            _removeBuyOrder(buy);\n        }\n\n        sell.amount = sell.amount.sub(tradedTokens);\n        if (sell.amount == 0) {\n            _removeSellOrder(sell);\n        }\n\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\n        sell.maker.transfer(tradedWei);\n\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n            sellTokenId, publishedRate, price, fillRate, tradedWei, tradedTokens);\n\n        return true;\n    }\n\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n    private returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\n\n        orderId = ++orderCount;\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n        activeSellOrders.push(orderId);\n\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n    }\n\n    function _removeBuyOrder(Order storage order) private {\n        _removeOrder(activeBuyOrders, order.index);\n    }\n\n    function _removeSellOrder(Order storage order) private {\n        _removeOrder(activeSellOrders, order.index);\n    }\n\n    function _removeOrder(uint64[] storage orders, uint64 index) private {\n        if (index < orders.length - 1) {\n            orders[index] = orders[orders.length - 1];\n        }\n        orders.length--;\n    }\n\n}\n"
        }
      }
    }
  }
}