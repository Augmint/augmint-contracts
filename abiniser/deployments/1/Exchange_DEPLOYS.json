{
  "contractName": "Exchange",
  "latestAbiHash": "d3e7f8a261b756f9c40da097608b21cd",
  "deployedAbis": {
    "b2a23202a9a0f04755a186896c2b56eb": {
      "latestDeployedAddress": "0x8b52b019d237d0bbe8baedf219132d5254e0690b",
      "deployments": {
        "0x8b52b019d237d0bbe8baedf219132d5254e0690b": {
          "generatedAt": "2018-06-11T14:59:44.035Z",
          "truffleContractFileUpdatedAt": "2018-06-11T14:55:55.596Z",
          "deployTransactionHash": "0x6e94d5201dc67810d50210f26464fe6ffa74454b8f2663809db37b01830070d5",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "09662358eb649fe02860d3f98722ee64",
          "deployedBytecodeHash": "5dc02051446dcb33dceff75a1635ea27",
          "sourceHash": "7a417a79bd6036b0b1b796d00bc176ca",
          "source": "/* Augmint's Internal Exchange\n\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n\n    TODO:\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n        - deduct fee\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n        - use Rates interface?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./Rates.sol\";\n\n\ncontract Exchange is Restricted {\n    using SafeMath for uint256;\n\n    AugmintTokenInterface public augmintToken;\n    Rates public rates;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    struct Order {\n        uint64 index;\n        address maker;\n\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n        uint32 price;\n\n        // buy order: amount in wei\n        // sell order: token amount\n        uint amount;\n    }\n\n    uint64 public orderCount;\n    mapping(uint64 => Order) public buyTokenOrders;\n    mapping(uint64 => Order) public sellTokenOrders;\n\n    uint64[] private activeBuyOrders;\n    uint64[] private activeSellOrders;\n\n    /* used to stop executing matchMultiple when running out of gas.\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint fillRate, uint weiAmount, uint tokenAmount);\n\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n\n    event RatesContractChanged(Rates newRatesContract);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        rates = _rates;\n    }\n\n    /* to allow upgrade of Rates  contract */\n    function setRatesContract(Rates newRatesContract)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        emit RatesContractChanged(newRatesContract);\n    }\n\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(msg.value > 0, \"msg.value must be > 0\");\n\n        orderId = ++orderCount;\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n        activeBuyOrders.push(orderId);\n\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n    }\n\n    /* this function requires previous approval to transfer tokens */\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n    }\n\n    /* place sell token order called from AugmintToken's transferAndNotify\n     Flow:\n        1) user calls token contract's transferAndNotify price passed in data arg\n        2) transferAndNotify transfers tokens to the Exchange contract\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n    */\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n    }\n\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n        Order storage order = buyTokenOrders[buyTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"buy order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeBuyOrder(order);\n\n        msg.sender.transfer(amount);\n\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n    }\n\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\n        Order storage order = sellTokenOrders[sellTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"sell order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeSellOrder(order);\n\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\n\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n    }\n\n    /* matches any two orders if the sell price >= buy price\n        trade price is the price of the maker (the order placed earlier)\n        reverts if any of the orders have been removed\n    */\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\n    }\n\n    /*  matches as many orders as possible from the passed orders\n        Runs as long as gas is available for the call.\n        Reverts if any match is invalid (e.g sell price > buy price)\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n    */\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n        uint len = buyTokenIds.length;\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\n\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n                matchCount++;\n            }\n        }\n    }\n\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n        return(activeBuyOrders.length, activeSellOrders.length);\n    }\n\n    // returns CHUNK_SIZE orders starting from offset\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveBuyOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeBuyOrders.length; i++) {\n            uint64 orderId = activeBuyOrders[offset + i];\n            Order storage order = buyTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    function getActiveSellOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeSellOrders.length; i++) {\n            uint64 orderId = activeSellOrders[offset + i];\n            Order storage order = sellTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n        Order storage buy = buyTokenOrders[buyTokenId];\n        Order storage sell = sellTokenOrders[sellTokenId];\n        if( buy.amount == 0 || sell.amount == 0 ) {\n            return false; // one order is already filled and removed.\n                          // we let matchMultiple continue, indivudal match will revert\n        }\n\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\n\n        // pick maker's price (whoever placed order sooner considered as maker)\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n\n        uint publishedRate;\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n        uint fillRate = publishedRate.mul(price).roundedDiv(1000000);\n\n        uint sellWei = sell.amount.mul(1 ether).roundedDiv(fillRate);\n\n        uint tradedWei;\n        uint tradedTokens;\n        if (sellWei <= buy.amount) {\n            tradedWei = sellWei;\n            tradedTokens = sell.amount;\n        } else {\n            tradedWei = buy.amount;\n            tradedTokens = buy.amount.mul(fillRate).roundedDiv(1 ether);\n        }\n\n        buy.amount = buy.amount.sub(tradedWei);\n        if (buy.amount == 0) {\n            _removeBuyOrder(buy);\n        }\n\n        sell.amount = sell.amount.sub(tradedTokens);\n        if (sell.amount == 0) {\n            _removeSellOrder(sell);\n        }\n\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\n        sell.maker.transfer(tradedWei);\n\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n            sellTokenId, publishedRate, price, fillRate, tradedWei, tradedTokens);\n\n        return true;\n    }\n\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n    private returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\n\n        orderId = ++orderCount;\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n        activeSellOrders.push(orderId);\n\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n    }\n\n    function _removeBuyOrder(Order storage order) private {\n        _removeOrder(activeBuyOrders, order.index);\n    }\n\n    function _removeSellOrder(Order storage order) private {\n        _removeOrder(activeSellOrders, order.index);\n    }\n\n    function _removeOrder(uint64[] storage orders, uint64 index) private {\n        if (index < orders.length - 1) {\n            orders[index] = orders[orders.length - 1];\n        }\n        orders.length--;\n    }\n\n}\n"
        }
      }
    },
    "c28de2392aea85ef2aa1b108fce6568c": {
      "latestDeployedAddress": "0xafea54badf7a68f93c2235b5f4cc8f02a2b55edd",
      "deployments": {
        "0xeae7d30bcd44f27d58985b56add007fcee254abd": {
          "generatedAt": "2018-08-24T11:57:19.856Z",
          "truffleContractFileUpdatedAt": "2018-08-24T11:56:50.685Z",
          "deployTransactionHash": "0x63c1f732ab97198940c599777736d3aca263d1c8bfdc26a2adf44fbfe7e7da09",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "214d9b21e9fc776631897c811d75e7a7",
          "deployedBytecodeHash": "c55ed2d4c5fb27f191f7d3e043afe771",
          "sourceHash": "666961af517c36b10580b52699ba5ae9",
          "source": "/* Augmint's Internal Exchange\n\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n\n    TODO:\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n        - deduct fee\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n        - use Rates interface?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./Rates.sol\";\n\n\ncontract Exchange is Restricted {\n    using SafeMath for uint256;\n\n    AugmintTokenInterface public augmintToken;\n    Rates public rates;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    struct Order {\n        uint64 index;\n        address maker;\n\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n        uint32 price;\n\n        // buy order: amount in wei\n        // sell order: token amount\n        uint amount;\n    }\n\n    uint64 public orderCount;\n    mapping(uint64 => Order) public buyTokenOrders;\n    mapping(uint64 => Order) public sellTokenOrders;\n\n    uint64[] private activeBuyOrders;\n    uint64[] private activeSellOrders;\n\n    /* used to stop executing matchMultiple when running out of gas.\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint weiAmount, uint tokenAmount);\n\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n\n    event RatesContractChanged(Rates newRatesContract);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        rates = _rates;\n    }\n\n    /* to allow upgrade of Rates  contract */\n    function setRatesContract(Rates newRatesContract)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        emit RatesContractChanged(newRatesContract);\n    }\n\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(msg.value > 0, \"msg.value must be > 0\");\n\n        orderId = ++orderCount;\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n        activeBuyOrders.push(orderId);\n\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n    }\n\n    /* this function requires previous approval to transfer tokens */\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n    }\n\n    /* place sell token order called from AugmintToken's transferAndNotify\n     Flow:\n        1) user calls token contract's transferAndNotify price passed in data arg\n        2) transferAndNotify transfers tokens to the Exchange contract\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n    */\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n    }\n\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n        Order storage order = buyTokenOrders[buyTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"buy order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeBuyOrder(order);\n\n        msg.sender.transfer(amount);\n\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n    }\n\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\n        Order storage order = sellTokenOrders[sellTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"sell order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeSellOrder(order);\n\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\n\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n    }\n\n    /* matches any two orders if the sell price >= buy price\n        trade price is the price of the maker (the order placed earlier)\n        reverts if any of the orders have been removed\n    */\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\n    }\n\n    /*  matches as many orders as possible from the passed orders\n        Runs as long as gas is available for the call.\n        Reverts if any match is invalid (e.g sell price > buy price)\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n    */\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n        uint len = buyTokenIds.length;\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\n\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n                matchCount++;\n            }\n        }\n    }\n\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n        return(activeBuyOrders.length, activeSellOrders.length);\n    }\n\n    // returns CHUNK_SIZE orders starting from offset\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveBuyOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeBuyOrders.length; i++) {\n            uint64 orderId = activeBuyOrders[offset + i];\n            Order storage order = buyTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    function getActiveSellOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeSellOrders.length; i++) {\n            uint64 orderId = activeSellOrders[offset + i];\n            Order storage order = sellTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    uint private constant E12 = 1000000000000;\n\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n        Order storage buy = buyTokenOrders[buyTokenId];\n        Order storage sell = sellTokenOrders[sellTokenId];\n        if( buy.amount == 0 || sell.amount == 0 ) {\n            return false; // one order is already filled and removed.\n                          // we let matchMultiple continue, indivudal match will revert\n        }\n\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\n\n        // pick maker's price (whoever placed order sooner considered as maker)\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n\n        uint publishedRate;\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n        // fillRate = publishedRate * 1000000 / price\n\n        uint sellWei = sell.amount.mul(uint(price)).mul(E12).roundedDiv(publishedRate);\n\n        uint tradedWei;\n        uint tradedTokens;\n        if (sellWei <= buy.amount) {\n            tradedWei = sellWei;\n            tradedTokens = sell.amount;\n        } else {\n            tradedWei = buy.amount;\n            tradedTokens = buy.amount.mul(publishedRate).roundedDiv(uint(price).mul(E12));\n        }\n\n        buy.amount = buy.amount.sub(tradedWei);\n        if (buy.amount == 0) {\n            _removeBuyOrder(buy);\n        }\n\n        sell.amount = sell.amount.sub(tradedTokens);\n        if (sell.amount == 0) {\n            _removeSellOrder(sell);\n        }\n\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\n        sell.maker.transfer(tradedWei);\n\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n            sellTokenId, publishedRate, price, tradedWei, tradedTokens);\n\n        return true;\n    }\n\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n    private returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\n\n        orderId = ++orderCount;\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n        activeSellOrders.push(orderId);\n\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n    }\n\n    function _removeBuyOrder(Order storage order) private {\n        _removeOrder(activeBuyOrders, order.index);\n    }\n\n    function _removeSellOrder(Order storage order) private {\n        _removeOrder(activeSellOrders, order.index);\n    }\n\n    function _removeOrder(uint64[] storage orders, uint64 index) private {\n        if (index < orders.length - 1) {\n            orders[index] = orders[orders.length - 1];\n        }\n        orders.length--;\n    }\n\n}\n"
        },
        "0xafea54badf7a68f93c2235b5f4cc8f02a2b55edd": {
          "generatedAt": "2018-09-12T13:20:55.240Z",
          "truffleContractFileUpdatedAt": "2018-09-12T12:53:50.567Z",
          "deployTransactionHash": "0x635f5a5c3a4f52c2c566af7025e9cba14c9cc2250329dc9cad0935aa386e80c6",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "223ee21caaeb265ed1ea7331ad7c92c7",
          "deployedBytecodeHash": "b906f4b8d33bc83dd42cf4e56efa0bf8",
          "sourceHash": "2fd035bece27394255c74c60658546e5",
          "source": "/* Augmint's Internal Exchange\n\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n\n    TODO:\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n        - deduct fee\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n        - use Rates interface?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./Rates.sol\";\n\n\ncontract Exchange is Restricted {\n    using SafeMath for uint256;\n\n    AugmintTokenInterface public augmintToken;\n    Rates public rates;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    struct Order {\n        uint64 index;\n        address maker;\n\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n        uint32 price;\n\n        // buy order: amount in wei\n        // sell order: token amount\n        uint amount;\n    }\n\n    uint64 public orderCount;\n    mapping(uint64 => Order) public buyTokenOrders;\n    mapping(uint64 => Order) public sellTokenOrders;\n\n    uint64[] private activeBuyOrders;\n    uint64[] private activeSellOrders;\n\n    /* used to stop executing matchMultiple when running out of gas.\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint weiAmount, uint tokenAmount);\n\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n\n    event RatesContractChanged(Rates newRatesContract);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        rates = _rates;\n    }\n\n    /* to allow upgrade of Rates  contract */\n    function setRatesContract(Rates newRatesContract)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        emit RatesContractChanged(newRatesContract);\n    }\n\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(msg.value > 0, \"msg.value must be > 0\");\n\n        orderId = ++orderCount;\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n        activeBuyOrders.push(orderId);\n\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n    }\n\n    /* this function requires previous approval to transfer tokens */\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n    }\n\n    /* place sell token order called from AugmintToken's transferAndNotify\n     Flow:\n        1) user calls token contract's transferAndNotify price passed in data arg\n        2) transferAndNotify transfers tokens to the Exchange contract\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n    */\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n    }\n\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n        Order storage order = buyTokenOrders[buyTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"buy order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeBuyOrder(order);\n\n        msg.sender.transfer(amount);\n\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n    }\n\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\n        Order storage order = sellTokenOrders[sellTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"sell order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeSellOrder(order);\n\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\n\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n    }\n\n    /* matches any two orders if the sell price >= buy price\n        trade price is the price of the maker (the order placed earlier)\n        reverts if any of the orders have been removed\n    */\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\n    }\n\n    /*  matches as many orders as possible from the passed orders\n        Runs as long as gas is available for the call.\n        Reverts if any match is invalid (e.g sell price > buy price)\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n    */\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n        uint len = buyTokenIds.length;\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\n\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n                matchCount++;\n            }\n        }\n    }\n\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n        return(activeBuyOrders.length, activeSellOrders.length);\n    }\n\n    // returns CHUNK_SIZE orders starting from offset\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveBuyOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeBuyOrders.length; i++) {\n            uint64 orderId = activeBuyOrders[offset + i];\n            Order storage order = buyTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    function getActiveSellOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeSellOrders.length; i++) {\n            uint64 orderId = activeSellOrders[offset + i];\n            Order storage order = sellTokenOrders[orderId];\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n    }\n\n    uint private constant E12 = 1000000000000;\n\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n        Order storage buy = buyTokenOrders[buyTokenId];\n        Order storage sell = sellTokenOrders[sellTokenId];\n        if( buy.amount == 0 || sell.amount == 0 ) {\n            return false; // one order is already filled and removed.\n                          // we let matchMultiple continue, indivudal match will revert\n        }\n\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\n\n        // pick maker's price (whoever placed order sooner considered as maker)\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n\n        uint publishedRate;\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n        // fillRate = publishedRate * 1000000 / price\n\n        uint sellWei = sell.amount.mul(uint(price)).mul(E12).roundedDiv(publishedRate);\n\n        uint tradedWei;\n        uint tradedTokens;\n        if (sellWei <= buy.amount) {\n            tradedWei = sellWei;\n            tradedTokens = sell.amount;\n        } else {\n            tradedWei = buy.amount;\n            tradedTokens = buy.amount.mul(publishedRate).roundedDiv(uint(price).mul(E12));\n        }\n\n        buy.amount = buy.amount.sub(tradedWei);\n        if (buy.amount == 0) {\n            _removeBuyOrder(buy);\n        }\n\n        sell.amount = sell.amount.sub(tradedTokens);\n        if (sell.amount == 0) {\n            _removeSellOrder(sell);\n        }\n\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\n        sell.maker.transfer(tradedWei);\n\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n            sellTokenId, publishedRate, price, tradedWei, tradedTokens);\n\n        return true;\n    }\n\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n    private returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\n\n        orderId = ++orderCount;\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n        activeSellOrders.push(orderId);\n\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n    }\n\n    function _removeBuyOrder(Order storage order) private {\n        uint lastIndex = activeBuyOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeBuyOrders[lastIndex];\n            activeBuyOrders[order.index] = movedOrderId;\n            buyTokenOrders[movedOrderId].index = order.index;\n        }\n        activeBuyOrders.length--;\n    }\n\n    function _removeSellOrder(Order storage order) private {\n        uint lastIndex = activeSellOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeSellOrders[lastIndex];\n            activeSellOrders[order.index] = movedOrderId;\n            sellTokenOrders[movedOrderId].index = order.index;\n        }\n        activeSellOrders.length--;\n    }\n}\n"
        }
      }
    },
    "d3e7f8a261b756f9c40da097608b21cd": {
      "latestDeployedAddress": "0xc670ffbfa21c37481fb4ef2ea2249b9b78d2b073",
      "deployments": {
        "0xc670ffbfa21c37481fb4ef2ea2249b9b78d2b073": {
          "generatedAt": "2018-11-14T12:52:13.099Z",
          "truffleContractFileUpdatedAt": "2018-11-13T16:34:24.470Z",
          "deployTransactionHash": "0x69fd88f120b060e54cddb1ef2dce3fd3acb2ae3006544a8905933e8bf5ebc85d",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "5a731d45c1595b7ffeb40bae693ef88d",
          "deployedBytecodeHash": "136e48f6880df5153792c846d87ddede",
          "sourceHash": "d6ff57acb1b45199b5dd08357978d8c2",
          "source": "/* Augmint's Internal Exchange\n\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n\n    TODO:\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n        - deduct fee\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n        - use Rates interface?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./Rates.sol\";\n\n\ncontract Exchange is Restricted {\n    using SafeMath for uint256;\n\n    AugmintTokenInterface public augmintToken;\n    Rates public rates;\n\n    struct Order {\n        uint64 index;\n        address maker;\n\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n        uint32 price;\n\n        // buy order: amount in wei\n        // sell order: token amount\n        uint amount;\n    }\n\n    uint64 public orderCount;\n    mapping(uint64 => Order) public buyTokenOrders;\n    mapping(uint64 => Order) public sellTokenOrders;\n\n    uint64[] private activeBuyOrders;\n    uint64[] private activeSellOrders;\n\n    /* used to stop executing matchMultiple when running out of gas.\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint weiAmount, uint tokenAmount);\n\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n\n    event RatesContractChanged(Rates newRatesContract);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        rates = _rates;\n    }\n\n    /* to allow upgrade of Rates  contract */\n    function setRatesContract(Rates newRatesContract)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        emit RatesContractChanged(newRatesContract);\n    }\n\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(msg.value > 0, \"msg.value must be > 0\");\n\n        orderId = ++orderCount;\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n        activeBuyOrders.push(orderId);\n\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n    }\n\n    /* this function requires previous approval to transfer tokens */\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n    }\n\n    /* place sell token order called from AugmintToken's transferAndNotify\n     Flow:\n        1) user calls token contract's transferAndNotify price passed in data arg\n        2) transferAndNotify transfers tokens to the Exchange contract\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n    */\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n    }\n\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n        Order storage order = buyTokenOrders[buyTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"buy order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeBuyOrder(order);\n\n        msg.sender.transfer(amount);\n\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n    }\n\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\n        Order storage order = sellTokenOrders[sellTokenId];\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\n        require(order.amount > 0, \"sell order already removed\");\n\n        uint amount = order.amount;\n        order.amount = 0;\n        _removeSellOrder(order);\n\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\n\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n    }\n\n    /* matches any two orders if the sell price >= buy price\n        trade price is the price of the maker (the order placed earlier)\n        reverts if any of the orders have been removed\n    */\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\n    }\n\n    /*  matches as many orders as possible from the passed orders\n        Runs as long as gas is available for the call.\n        Reverts if any match is invalid (e.g sell price > buy price)\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n    */\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n        uint len = buyTokenIds.length;\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\n\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n                matchCount++;\n            }\n        }\n    }\n\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n        return(activeBuyOrders.length, activeSellOrders.length);\n    }\n\n    // returns <chunkSize> active buy orders starting from <offset>\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveBuyOrders(uint offset, uint16 chunkSize)\n    external view returns (uint[4][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), activeBuyOrders.length);\n        uint[4][] memory response = new uint[4][](limit.sub(offset));\n        for (uint i = offset; i < limit; i++) {\n            uint64 orderId = activeBuyOrders[i];\n            Order storage order = buyTokenOrders[orderId];\n            response[i - offset] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n        return response;\n    }\n\n    // returns <chunkSize> active sell orders starting from <offset>\n    // orders are encoded as [id, maker, price, amount]\n    function getActiveSellOrders(uint offset, uint16 chunkSize)\n    external view returns (uint[4][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), activeSellOrders.length);\n        uint[4][] memory response = new uint[4][](limit.sub(offset));\n        for (uint i = offset; i < limit; i++) {\n            uint64 orderId = activeSellOrders[i];\n            Order storage order = sellTokenOrders[orderId];\n            response[i - offset] = [orderId, uint(order.maker), order.price, order.amount];\n        }\n        return response;\n    }\n\n    uint private constant E12 = 1000000000000;\n\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n        Order storage buy = buyTokenOrders[buyTokenId];\n        Order storage sell = sellTokenOrders[sellTokenId];\n        if( buy.amount == 0 || sell.amount == 0 ) {\n            return false; // one order is already filled and removed.\n                          // we let matchMultiple continue, indivudal match will revert\n        }\n\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\n\n        // pick maker's price (whoever placed order sooner considered as maker)\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n\n        uint publishedRate;\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n        // fillRate = publishedRate * 1000000 / price\n\n        uint sellWei = sell.amount.mul(uint(price)).mul(E12).roundedDiv(publishedRate);\n\n        uint tradedWei;\n        uint tradedTokens;\n        if (sellWei <= buy.amount) {\n            tradedWei = sellWei;\n            tradedTokens = sell.amount;\n        } else {\n            tradedWei = buy.amount;\n            tradedTokens = buy.amount.mul(publishedRate).roundedDiv(uint(price).mul(E12));\n        }\n\n        buy.amount = buy.amount.sub(tradedWei);\n        if (buy.amount == 0) {\n            _removeBuyOrder(buy);\n        }\n\n        sell.amount = sell.amount.sub(tradedTokens);\n        if (sell.amount == 0) {\n            _removeSellOrder(sell);\n        }\n\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\n        sell.maker.transfer(tradedWei);\n\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n            sellTokenId, publishedRate, price, tradedWei, tradedTokens);\n\n        return true;\n    }\n\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n    private returns (uint64 orderId) {\n        require(price > 0, \"price must be > 0\");\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\n\n        orderId = ++orderCount;\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n        activeSellOrders.push(orderId);\n\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n    }\n\n    function _removeBuyOrder(Order storage order) private {\n        uint lastIndex = activeBuyOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeBuyOrders[lastIndex];\n            activeBuyOrders[order.index] = movedOrderId;\n            buyTokenOrders[movedOrderId].index = order.index;\n        }\n        activeBuyOrders.length--;\n    }\n\n    function _removeSellOrder(Order storage order) private {\n        uint lastIndex = activeSellOrders.length - 1;\n        if (order.index < lastIndex) {\n            uint64 movedOrderId = activeSellOrders[lastIndex];\n            activeSellOrders[order.index] = movedOrderId;\n            sellTokenOrders[movedOrderId].index = order.index;\n        }\n        activeSellOrders.length--;\n    }\n}\n"
        }
      }
    }
  }
}