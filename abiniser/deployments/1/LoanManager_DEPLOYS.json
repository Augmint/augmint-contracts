{
  "contractName": "LoanManager",
  "latestAbiHash": "ec709c3341045caa3a75374b8cfc7286",
  "deployedAbis": {
    "ec709c3341045caa3a75374b8cfc7286": {
      "latestDeployedAddress": "0xcbefaf199b800deeb9ead61f358ee46e06c54070",
      "deployments": {
        "0xcbefaf199b800deeb9ead61f358ee46e06c54070": {
          "generatedAt": "2018-06-11T14:51:04.245Z",
          "truffleContractFileUpdatedAt": "2018-06-11T14:22:34.479Z",
          "deployTransactionHash": "0x6b4a94039ca2ebf7b9792bebf5f6267e0014cb98058215bd53e9b82e33e2e10f",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "023cda0e36eef3289f062fda7d3b3d1a",
          "deployedBytecodeHash": "1b89d6141a07f61e07790d5f4d97df58",
          "sourceHash": "184d41cf8c8c034dc64e026f5d33bc3c",
          "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity 0.4.24;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted {\n    using SafeMath for uint256;\n\n    uint16 public constant CHUNK_SIZE = 100;\n\n    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n\n    struct LoanProduct {\n        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n        uint32 term;            // 1\n        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n                                //      in parts per million , ie. 10,000 = 1%\n        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive;          // 5\n    }\n\n    /* NB: we don't need to store loan parameters because loan products can't be altered (only disabled/enabled) */\n    struct LoanData {\n        uint collateralAmount; // 0\n        uint repaymentAmount; // 1\n        address borrower; // 2\n        uint32 productId; // 3\n        LoanState state; // 4\n        uint40 maturity; // 5\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n\n    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount, uint40 maturity);\n\n    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n\n    event LoanProductAdded(uint32 productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    event SystemContractsChanged(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor);\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor, Rates _rates)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n    }\n\n    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n                                uint32 defaultingFeePt, bool isActive)\n    external restrict(\"StabilityBoard\") {\n\n        uint _newProductId = products.push(\n            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n        ) - 1;\n\n        uint32 newProductId = uint32(_newProductId);\n        require(newProductId == _newProductId, \"productId overflow\");\n\n        emit LoanProductAdded(newProductId);\n    }\n\n    function setLoanProductActiveState(uint32 productId, bool newState)\n    external restrict (\"StabilityBoard\") {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        products[productId].isActive = false;\n        emit LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint32 productId) external payable {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        LoanProduct storage product = products[productId];\n        require(product.isActive, \"product must be in active state\"); // valid product\n\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n\n        uint loanAmount;\n        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n\n        require(loanAmount >= product.minDisbursedAmount, \"loanAmount must be >= minDisbursedAmount\");\n\n        uint expiration = now.add(product.term);\n        uint40 maturity = uint40(expiration);\n        require(maturity == expiration, \"maturity overflow\");\n\n        // Create new loan\n        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n                                            productId, LoanState.Open, maturity)) - 1;\n\n        // Store ref to new loan\n        accountLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        emit NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        uint totalDefaultingFee;\n        for (uint i = 0; i < loanIds.length; i++) {\n            require(i < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n            LoanData storage loan = loans[loanIds[i]];\n            require(loan.state == LoanState.Open, \"loan state must be Open\");\n            require(now >= loan.maturity, \"current time must be later than maturity\");\n            LoanProduct storage product = products[loan.productId];\n\n            uint loanAmount;\n            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n\n            loan.state = LoanState.Collected;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n                                                            loan.repaymentAmount).add(defaultingFee);\n\n            uint releasedCollateral;\n            if (targetCollection < loan.collateralAmount) {\n                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n                loan.borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n            if (defaultingFee >= collateralToCollect) {\n                defaultingFee = collateralToCollect;\n                collateralToCollect = 0;\n            } else {\n                collateralToCollect = collateralToCollect.sub(defaultingFee);\n            }\n            totalDefaultingFee = totalDefaultingFee.add(defaultingFee);\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            emit LoanCollected(loanIds[i], loan.borrower, collateralToCollect.add(defaultingFee), releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            address(monetarySupervisor.augmintReserves()).transfer(totalCollateralToCollect);\n        }\n\n        if (totalDefaultingFee > 0){\n            address(augmintToken.feeAccount()).transfer(totalDefaultingFee);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    /* to allow upgrade of Rates and MonetarySupervisor contracts */\n    function setSystemContracts(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor)\n    external restrict(\"StabilityBoard\") {\n        rates = newRatesContract;\n        monetarySupervisor = newMonetarySupervisor;\n        emit SystemContractsChanged(newRatesContract, newMonetarySupervisor);\n    }\n\n    function getProductCount() external view returns (uint ct) {\n        return products.length;\n    }\n\n    // returns CHUNK_SIZE loan products starting from some offset:\n    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, maxLoanAmount, isActive ]\n    function getProducts(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= products.length) { break; }\n\n            LoanProduct storage product = products[offset + i];\n\n            response[i] = [offset + i, product.minDisbursedAmount, product.term, product.discountRate,\n                            product.collateralRatio, product.defaultingFeePt,\n                            monetarySupervisor.getMaxLoanAmount(product.minDisbursedAmount), product.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLoanCount() external view returns (uint ct) {\n        return loans.length;\n    }\n\n    /* returns CHUNK_SIZE loans starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ]   */\n    function getLoans(uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loans.length) { break; }\n\n            response[i] = getLoanTuple(offset + i);\n        }\n    }\n\n    function getLoanCountForAddress(address borrower) external view returns (uint) {\n        return accountLoans[borrower].length;\n    }\n\n    /* returns CHUNK_SIZE loans of a given account, starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ] */\n    function getLoansForAddress(address borrower, uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        uint[] storage loansForAddress = accountLoans[borrower];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loansForAddress.length) { break; }\n\n            response[i] = getLoanTuple(loansForAddress[offset + i]);\n        }\n    }\n\n    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        LoanProduct storage product = products[loan.productId];\n\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n        uint disbursementTime = loan.maturity - product.term;\n\n        LoanState loanState =\n                        loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n\n        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n                    loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n    }\n\n    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n    internal view returns (uint loanAmount, uint interestAmount) {\n        // calculate loan values based on repayment amount\n        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        require(loan.state == LoanState.Open, \"loan state must be Open\");\n        require(repaymentAmount == loan.repaymentAmount, \"repaymentAmount must be equal to tokens sent\");\n        require(now <= loan.maturity, \"current time must be earlier than maturity\");\n\n        LoanProduct storage product = products[loan.productId];\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n\n        loans[loanId].state = LoanState.Repaid;\n\n        if (interestAmount > 0) {\n            augmintToken.transfer(monetarySupervisor.interestEarnedAccount(), interestAmount);\n            augmintToken.burn(loanAmount);\n        } else {\n            // negative or zero interest (i.e. discountRate >= 0)\n            augmintToken.burn(repaymentAmount);\n        }\n\n        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n\n        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n\n        emit LoanRepayed(loanId, loan.borrower);\n    }\n\n}\n"
        }
      }
    }
  }
}