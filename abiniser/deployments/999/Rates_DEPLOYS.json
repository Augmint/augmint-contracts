{
  "contractName": "Rates",
  "latestAbiHash": "73a17ebb0acc71773371c6a8e1c8e6ce",
  "deployedAbis": {
    "aad689098442fe73d35b427a36786f06": {
      "latestDeployedAddress": "0x8b639dc72f3e640c0d6bc19497fbc7b5160d0463",
      "deployments": {
        "0x8b639dc72f3e640c0d6bc19497fbc7b5160d0463": {
          "generatedAt": "2018-04-25T12:30:49.023Z",
          "truffleContractFileUpdatedAt": "2018-02-27T07:31:58.107Z",
          "compiler": {
            "name": "solc",
            "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
          },
          "bytecodeHash": "b072f2ac9f39bd4e54ec18306443b251",
          "deployedBytecodeHash": "94217efb3293a39e7ccfaf54347d3bfe",
          "sourceHash": "6aba5d7c578a7c3d328066fa72de1429",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity 0.4.19;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"setRate\") {\n        rates[symbol] = RateInfo(newRate, now);\n        RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"setRate\") {\n        require(symbols.length == newRates.length);\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0);\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // no require(rates[symbol].rate >  0) needed b/c it will revert with div by zero\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        }
      }
    },
    "cc8bc64cd780f047eca819e6cd3b8af9": {
      "latestDeployedAddress": "0xa47b07db70126f0095b09c846d0d7e2d965eae6b",
      "deployments": {
        "0x8b639dc72f3e640c0d6bc19497fbc7b5160d0463": {
          "generatedAt": "2018-04-25T12:31:28.978Z",
          "truffleContractFileUpdatedAt": "2018-04-20T18:21:38.645Z",
          "deployTransactionHash": "0x2406592c676468988c721d4051e727eb5659016c6560234ea53a2e65775978c8",
          "compiler": {
            "name": "solc",
            "version": "0.4.23+commit.124ca40d.Emscripten.clang"
          },
          "bytecodeHash": "7b3cb84bdbfbe54d0c253744ccc86bd9",
          "deployedBytecodeHash": "36714b840505a1bedac90a82a36e514c",
          "sourceHash": "e9dda67ca678fd3a4700e8970b50acd3",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity ^0.4.23;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"setRate\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"setRate\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        },
        "0xd3ef19679c2dbbf3b8e2077c61b88f5e9c6178eb": {
          "generatedAt": "2018-05-09T12:19:24.837Z",
          "truffleContractFileUpdatedAt": "2018-05-09T12:19:15.658Z",
          "deployTransactionHash": "0xf54d0cd33fc046bdca1066c84c2c1af0a3064d14b41d820a952d6739e015de6b",
          "compiler": {
            "name": "solc",
            "version": "0.4.23+commit.124ca40d.Emscripten.clang"
          },
          "bytecodeHash": "7b3cb84bdbfbe54d0c253744ccc86bd9",
          "deployedBytecodeHash": "36714b840505a1bedac90a82a36e514c",
          "sourceHash": "e9dda67ca678fd3a4700e8970b50acd3",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity ^0.4.23;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"setRate\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"setRate\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        },
        "0xa47b07db70126f0095b09c846d0d7e2d965eae6b": {
          "generatedAt": "2018-05-31T23:56:48.438Z",
          "truffleContractFileUpdatedAt": "2018-05-31T23:54:54.495Z",
          "deployTransactionHash": "0x00b941f25c54731b9920198c6d89223ffe7e50dd06ed65b820b51190ffd8fb07",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "3b2f1c4e52d682390b3e3f52bfb7149e",
          "deployedBytecodeHash": "ba3833719d4aefe680165cbe9faa139f",
          "sourceHash": "0c937a45e5ca30ca3cc1314b3cc1fd39",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"setRate\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"setRate\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        }
      }
    },
    "73a17ebb0acc71773371c6a8e1c8e6ce": {
      "latestDeployedAddress": "0xb0a2a8e846b66c7384f52635cecef5280f766c8b",
      "deployments": {
        "0xb0a2a8e846b66c7384f52635cecef5280f766c8b": {
          "generatedAt": "2018-06-06T15:25:31.715Z",
          "truffleContractFileUpdatedAt": "2018-06-06T15:25:22.676Z",
          "deployTransactionHash": "0x81ac7d900a76ab42715ec20fef4d2f1221525e0e241ede2188947af4ef34678d",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "b2bf3f97147e9144c7103442be20e58a",
          "deployedBytecodeHash": "6a3a4ec8c050710692adaa9f97d09bb6",
          "sourceHash": "d71ec203e7ee6ed376feeb17e5df7966",
          "source": "/*\n Generic symbol / WEI rates contract.\n only callable by trusted price oracles.\n Being regularly called by a price oracle\n    TODO: trustless/decentrilezed price Oracle\n    TODO: shall we use blockNumber instead of now for lastUpdated?\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n*/\npragma solidity 0.4.24;\n\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract Rates is Restricted {\n    using SafeMath for uint256;\n\n    struct RateInfo {\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n                    // 0 rate means no rate info available\n        uint lastUpdated;\n    }\n\n    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n    mapping(bytes32 => RateInfo) public rates;\n\n    event RateChanged(bytes32 symbol, uint newRate);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"RatesFeeder\") {\n        rates[symbol] = RateInfo(newRate, now);\n        emit RateChanged(symbol, newRate);\n    }\n\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"RatesFeeder\") {\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\n        for (uint256 i = 0; i < symbols.length; i++) {\n            rates[symbols[i]] = RateInfo(newRates[i], now);\n            emit RateChanged(symbols[i], newRates[i]);\n        }\n    }\n\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n    }\n\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n        // next line would revert with div by zero but require to emit reason\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\n        /* TODO: can we make this not loosing max scale? */\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n    }\n\n}\n"
        }
      }
    }
  }
}