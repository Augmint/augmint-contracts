{
  "contractName": "PreToken",
  "latestAbiHash": "10eebbb51a771cfd3473475169a569f1",
  "deployedAbis": {
    "771887af92db4b4330d700538df6e490": {
      "latestDeployedAddress": "0xbed57eb0b4232da0cddd3c9c27490fc0759e0a01",
      "deployments": {
        "0xbed57eb0b4232da0cddd3c9c27490fc0759e0a01": {
          "generatedAt": "2018-06-07T13:00:00.734Z",
          "truffleContractFileUpdatedAt": "2018-06-07T12:51:20.015Z",
          "deployTransactionHash": "0x393ce3b7bfd805b5b8ffb162602b4c294d616c1c3ad84e433ae0bed7a80ee396",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "4c28508dceb343d11fc03065ea0a4dfb",
          "deployedBytecodeHash": "4e60c77460939aa05c185f2d2e341660",
          "sourceHash": "cab74a015e98f8925b8866d60ca94278",
          "source": "/* Augmint pretoken contract to record tokens allocated based on agreements.\nThese tokens are not fungible because agreements can have different conditions (valuationCap and discount).\nDespite being non-fungible some ERC20 functions are implemented so agreement owners can see their balances and transfers\n    in standard wallets.\nWhere it's not ERC20 compliant:\n  - transfer is only allowed by agreement holders (to avoid polluting transfer logs)\n  - transfer is only allowed to accounts without an agreement yet or same agreement\n  - no approval and transferFrom\n */\n\npragma solidity 0.4.24;\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract PreToken is Restricted {\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    string constant public name = \"Augmint pretokens\"; // solhint-disable-line const-name-snakecase\n    string constant public symbol = \"APRE\"; // solhint-disable-line const-name-snakecase\n    uint8 constant public decimals = 0; // solhint-disable-line const-name-snakecase\n\n    uint public totalSupply;\n\n    struct Agreement {\n        uint balance;\n        bytes32 agreementHash; // SHA-2 (SHA-256) hash of signed agreement.\n                              // OSX: shasum -a 256 agreement.pdf\n                              // Windows: certUtil -hashfile agreement.pdf SHA256\n        uint32 discount; //  discountRate in parts per million , ie. 10,000 = 1%\n        uint32 valuationCap; // in USD (no decimals)\n    }\n\n    mapping(address => Agreement) public agreements; // Balances for each account\n    address[] public allAgreements; // all addresses with agreements to able to iterate over\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    event NewAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function addAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap)\n    external restrict(\"PreTokenSigner\") {\n        require(owner != address(0));\n        require(agreements[owner].agreementHash == 0x0);\n        require(agreementHash != 0x0);\n\n        agreements[owner] = Agreement(0, agreementHash, discount, valuationCap);\n        allAgreements.push(owner);\n\n        emit NewAgreement(owner, agreementHash, discount, valuationCap);\n    }\n\n    function issueTo(address _to, uint amount) external restrict(\"PreTokenSigner\") {\n        Agreement storage to = agreements[_to];\n        require(to.agreementHash != 0x0);\n\n        to.balance = to.balance.add(amount);\n        totalSupply = totalSupply.add(amount);\n\n        emit Transfer(0x0, _to, amount);\n    }\n\n    /* Restricted function to allow pretoken signers to fix incorrect issuance */\n    function burnFrom(address from, uint amount)\n    public restrict(\"PreTokenSigner\") returns (bool) {\n        require(amount > 0, \"burn amount must be > 0\"); // this effectively restricts burning from agreement holders only\n        require(agreements[from].balance >= amount, \"must not burn more than balance\"); // .sub would revert anyways but emit reason\n\n        agreements[from].balance = agreements[from].balance.sub(amount);\n        totalSupply = totalSupply.sub(amount);\n\n        emit Transfer(from, 0x0, amount);\n        return true;\n    }\n\n    function balanceOf(address who) public view returns (uint) {\n        return agreements[who].balance;\n    }\n\n    function transfer(address to, uint amount) public returns (bool) { // solhint-disable-line no-simple-event-func-name\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /* Restricted function to allow pretoken signers to fix if pretoken owner lost keys */\n    function transferFrom(address from, address to, uint amount)\n    public restrict(\"PreTokenSigner\") returns (bool) {\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /* private function used by transferFrom & transfer */\n    function _transfer(address from, address to, uint amount) private {\n        require(agreements[from].agreementHash != 0x0, \"only holder of an agreement can transfer\");\n        require(to != 0x0, \"must not transfer to 0x0\");\n        require(\n            agreements[to].agreementHash == 0 ||  // allow to transfer to address without agreement\n            amount == 0 || // allow 0 amount transfers to any acc for voting\n            agreements[to].agreementHash == agreements[from].agreementHash // allow transfer to acc w/ same agr.\n        );\n\n        if (amount > 0) { // transfer agreement if it's not a 0 amount \"vote only\" transfer\n            agreements[from].balance = agreements[from].balance.sub(amount);\n            agreements[to].balance = agreements[to].balance.add(amount);\n\n            agreements[to].agreementHash = agreements[from].agreementHash;\n            agreements[to].valuationCap = agreements[from].valuationCap;\n            agreements[to].discount = agreements[from].discount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n\n    function getAgreementsCount() external view returns (uint agreementsCount) {\n        return allAgreements.length;\n    }\n\n    // UI helper fx - Returns all agreements from offset as\n    // [index in allAgreements, account address as uint, balance, agreementHash as uint,\n    //          discount as uint, valuationCap as uint ]\n    function getAllAgreements(uint offset) external view returns(uint[6][CHUNK_SIZE] agreementsResult) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allAgreements.length; i++) {\n            address agreementAccount = allAgreements[i + offset];\n            Agreement storage agreement = agreements[agreementAccount];\n            agreementsResult[i] = [ i + offset, uint(agreementAccount), agreement.balance,\n                uint(agreement.agreementHash), uint(agreement.discount), uint(agreement.valuationCap)];\n        }\n    }\n\n}\n"
        }
      }
    },
    "10eebbb51a771cfd3473475169a569f1": {
      "latestDeployedAddress": "0xbed57eb0b4232da0cddd3c9c27490fc0759e0a01",
      "deployments": {
        "0xbed57eb0b4232da0cddd3c9c27490fc0759e0a01": {
          "generatedAt": "2018-06-08T15:49:18.205Z",
          "truffleContractFileUpdatedAt": "2018-06-08T15:49:09.064Z",
          "deployTransactionHash": "0x458fb5e72d68e8a0585dcbde068baa1735442ffc249a27078332d06a7e28e73a",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "1a1d2eee97db1fda81f02d5a4693cccc",
          "deployedBytecodeHash": "39ecab521022215d08af346c490a4773",
          "sourceHash": "652361fe32b441561edaf8ebd7f70277",
          "source": "/* Augmint pretoken contract to record agreements and tokens allocated based on the agreement.\n\n    Important: this is NOT an ERC20 token!\n\n    PreTokens are non-fungible: agreements can have different conditions (valuationCap and discount)\n        and pretokens are not tradable.\n\n    Ownership can be transferred if owner wants to change wallet but the whole agreement and\n        the total pretoken amount is moved to a new account\n\n    PreTokenSigner can (via MultiSig):\n      - add agreements and issue pretokens to an agreement\n      - change owner of any agreement to handle if an owner lost a private keys\n      - burn pretokens from any agreement to fix potential erroneous issuance\n    These are known compromises on trustlessness hence all these tokens distributed based on signed agreements and\n        preTokens are issued only to a closed group of contributors / team members.\n    If despite these something goes wrong then as a last resort a new pretoken contract can be recreated from agreements.\n\n    Some ERC20 functions are implemented so agreement owners can see their balances and use transfer in standard wallets.\n    Restrictions:\n      - only total balance can be transfered - effectively ERC20 transfer used to transfer agreement ownership\n      - only agreement holders can transfer\n        (i.e. can't transfer 0 amount if have no agreement to avoid polluting logs with Transfer events)\n      - transfer is only allowed to accounts without an agreement yet\n      - no approval and transferFrom ERC20 functions\n */\n\npragma solidity 0.4.24;\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract PreToken is Restricted {\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    string constant public name = \"Augmint pretokens\"; // solhint-disable-line const-name-snakecase\n    string constant public symbol = \"APRE\"; // solhint-disable-line const-name-snakecase\n    uint8 constant public decimals = 0; // solhint-disable-line const-name-snakecase\n\n    uint public totalSupply;\n\n    struct Agreement {\n        address owner;\n        uint balance;\n        uint32 discount; //  discountRate in parts per million , ie. 10,000 = 1%\n        uint32 valuationCap; // in USD (no decimals)\n    }\n\n    /* Agreement hash is the SHA-2 (SHA-256) hash of signed agreement document.\n         To generate:\n            OSX: shasum -a 256 agreement.pdf\n            Windows: certUtil -hashfile agreement.pdf SHA256 */\n    mapping(address => bytes32) public agreementOwners; // to lookup agrement by owner\n    mapping(bytes32 => Agreement) public agreements;\n\n    bytes32[] public allAgreements; // all agreements to able to iterate over\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    event NewAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function addAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap)\n    external restrict(\"PreTokenSigner\") {\n        require(owner != address(0), \"owner must not be 0x0\");\n        require(agreementOwners[owner] == 0x0, \"owner must not have an aggrement yet\");\n        require(agreementHash != 0x0, \"agreementHash must not be 0x0\");\n        require(discount > 0, \"discount must be > 0\");\n        require(agreements[agreementHash].discount == 0, \"agreement must not exist yet\");\n\n        agreements[agreementHash] = Agreement(owner, 0, discount, valuationCap);\n        agreementOwners[owner] = agreementHash;\n        allAgreements.push(agreementHash);\n\n        emit NewAgreement(owner, agreementHash, discount, valuationCap);\n    }\n\n    function issueTo(bytes32 agreementHash, uint amount) external restrict(\"PreTokenSigner\") {\n        Agreement storage agreement = agreements[agreementHash];\n        require(agreement.discount > 0, \"agreement must exist\");\n\n        agreement.balance = agreement.balance.add(amount);\n        totalSupply = totalSupply.add(amount);\n\n        emit Transfer(0x0, agreement.owner, amount);\n    }\n\n    /* Restricted function to allow pretoken signers to fix incorrect issuance */\n    function burnFrom(bytes32 agreementHash, uint amount)\n    public restrict(\"PreTokenSigner\") returns (bool) {\n        Agreement storage agreement = agreements[agreementHash];\n        require(agreement.discount > 0, \"agreement must exist\"); // this is redundant b/c of next requires but be explicit\n        require(amount > 0, \"burn amount must be > 0\");\n        require(agreement.balance >= amount, \"must not burn more than balance\"); // .sub would revert anyways but emit reason\n\n        agreement.balance = agreement.balance.sub(amount);\n        totalSupply = totalSupply.sub(amount);\n\n        emit Transfer(agreement.owner, 0x0, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint) {\n        return agreements[agreementOwners[owner]].balance;\n    }\n\n    /* function to transfer agreement ownership to other wallet by owner\n        it's in ERC20 form so owners can use standard ERC20 wallet just need to pass full balance as value */\n    function transfer(address to, uint amount) public returns (bool) { // solhint-disable-line no-simple-event-func-name\n        require(amount == agreements[agreementOwners[msg.sender]].balance, \"must transfer full balance\");\n        _transfer(msg.sender, to);\n        return true;\n    }\n\n    /* Restricted function to allow pretoken signers to fix if pretoken owner lost keys */\n    function transferAgreement(bytes32 agreementHash, address to)\n    public restrict(\"PreTokenSigner\") returns (bool) {\n        _transfer(agreements[agreementHash].owner, to);\n        return true;\n    }\n\n    /* private function used by transferAgreement & transfer */\n    function _transfer(address from, address to) private {\n        Agreement storage agreement = agreements[agreementOwners[from]];\n        require(agreementOwners[from] != 0x0, \"from agreement must exists\");\n        require(agreementOwners[to] == 0, \"to must not have an agreement\");\n        require(to != 0x0, \"must not transfer to 0x0\");\n\n        agreement.owner = to;\n\n        agreementOwners[to] = agreementOwners[from];\n        agreementOwners[from] = 0x0;\n\n        emit Transfer(from, to, agreement.balance);\n    }\n\n    function getAgreementsCount() external view returns (uint agreementsCount) {\n        return allAgreements.length;\n    }\n\n    // UI helper fx - Returns all agreements from offset as\n    // [index in allAgreements, account address as uint, balance, agreementHash as uint,\n    //          discount as uint, valuationCap as uint ]\n    function getAllAgreements(uint offset) external view returns(uint[6][CHUNK_SIZE] agreementsResult) {\n\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allAgreements.length; i++) {\n            bytes32 agreementHash = allAgreements[i + offset];\n            Agreement storage agreement = agreements[agreementHash];\n\n            agreementsResult[i] = [ i + offset, uint(agreement.owner), agreement.balance,\n                uint(agreementHash), uint(agreement.discount), uint(agreement.valuationCap)];\n        }\n    }\n}\n"
        }
      }
    }
  }
}