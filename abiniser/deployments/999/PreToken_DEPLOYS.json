{
  "contractName": "PreToken",
  "latestAbiHash": "771887af92db4b4330d700538df6e490",
  "deployedAbis": {
    "771887af92db4b4330d700538df6e490": {
      "latestDeployedAddress": "0xbed57eb0b4232da0cddd3c9c27490fc0759e0a01",
      "deployments": {
        "0xbed57eb0b4232da0cddd3c9c27490fc0759e0a01": {
          "generatedAt": "2018-06-07T13:00:00.734Z",
          "truffleContractFileUpdatedAt": "2018-06-07T12:51:20.015Z",
          "deployTransactionHash": "0x393ce3b7bfd805b5b8ffb162602b4c294d616c1c3ad84e433ae0bed7a80ee396",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "4c28508dceb343d11fc03065ea0a4dfb",
          "deployedBytecodeHash": "4e60c77460939aa05c185f2d2e341660",
          "sourceHash": "cab74a015e98f8925b8866d60ca94278",
          "source": "/* Augmint pretoken contract to record tokens allocated based on agreements.\nThese tokens are not fungible because agreements can have different conditions (valuationCap and discount).\nDespite being non-fungible some ERC20 functions are implemented so agreement owners can see their balances and transfers\n    in standard wallets.\nWhere it's not ERC20 compliant:\n  - transfer is only allowed by agreement holders (to avoid polluting transfer logs)\n  - transfer is only allowed to accounts without an agreement yet or same agreement\n  - no approval and transferFrom\n */\n\npragma solidity 0.4.24;\nimport \"./generic/SafeMath.sol\";\nimport \"./generic/Restricted.sol\";\n\n\ncontract PreToken is Restricted {\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    string constant public name = \"Augmint pretokens\"; // solhint-disable-line const-name-snakecase\n    string constant public symbol = \"APRE\"; // solhint-disable-line const-name-snakecase\n    uint8 constant public decimals = 0; // solhint-disable-line const-name-snakecase\n\n    uint public totalSupply;\n\n    struct Agreement {\n        uint balance;\n        bytes32 agreementHash; // SHA-2 (SHA-256) hash of signed agreement.\n                              // OSX: shasum -a 256 agreement.pdf\n                              // Windows: certUtil -hashfile agreement.pdf SHA256\n        uint32 discount; //  discountRate in parts per million , ie. 10,000 = 1%\n        uint32 valuationCap; // in USD (no decimals)\n    }\n\n    mapping(address => Agreement) public agreements; // Balances for each account\n    address[] public allAgreements; // all addresses with agreements to able to iterate over\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n\n    event NewAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap);\n\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n\n    function addAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap)\n    external restrict(\"PreTokenSigner\") {\n        require(owner != address(0));\n        require(agreements[owner].agreementHash == 0x0);\n        require(agreementHash != 0x0);\n\n        agreements[owner] = Agreement(0, agreementHash, discount, valuationCap);\n        allAgreements.push(owner);\n\n        emit NewAgreement(owner, agreementHash, discount, valuationCap);\n    }\n\n    function issueTo(address _to, uint amount) external restrict(\"PreTokenSigner\") {\n        Agreement storage to = agreements[_to];\n        require(to.agreementHash != 0x0);\n\n        to.balance = to.balance.add(amount);\n        totalSupply = totalSupply.add(amount);\n\n        emit Transfer(0x0, _to, amount);\n    }\n\n    /* Restricted function to allow pretoken signers to fix incorrect issuance */\n    function burnFrom(address from, uint amount)\n    public restrict(\"PreTokenSigner\") returns (bool) {\n        require(amount > 0, \"burn amount must be > 0\"); // this effectively restricts burning from agreement holders only\n        require(agreements[from].balance >= amount, \"must not burn more than balance\"); // .sub would revert anyways but emit reason\n\n        agreements[from].balance = agreements[from].balance.sub(amount);\n        totalSupply = totalSupply.sub(amount);\n\n        emit Transfer(from, 0x0, amount);\n        return true;\n    }\n\n    function balanceOf(address who) public view returns (uint) {\n        return agreements[who].balance;\n    }\n\n    function transfer(address to, uint amount) public returns (bool) { // solhint-disable-line no-simple-event-func-name\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /* Restricted function to allow pretoken signers to fix if pretoken owner lost keys */\n    function transferFrom(address from, address to, uint amount)\n    public restrict(\"PreTokenSigner\") returns (bool) {\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /* private function used by transferFrom & transfer */\n    function _transfer(address from, address to, uint amount) private {\n        require(agreements[from].agreementHash != 0x0, \"only holder of an agreement can transfer\");\n        require(to != 0x0, \"must not transfer to 0x0\");\n        require(\n            agreements[to].agreementHash == 0 ||  // allow to transfer to address without agreement\n            amount == 0 || // allow 0 amount transfers to any acc for voting\n            agreements[to].agreementHash == agreements[from].agreementHash // allow transfer to acc w/ same agr.\n        );\n\n        if (amount > 0) { // transfer agreement if it's not a 0 amount \"vote only\" transfer\n            agreements[from].balance = agreements[from].balance.sub(amount);\n            agreements[to].balance = agreements[to].balance.add(amount);\n\n            agreements[to].agreementHash = agreements[from].agreementHash;\n            agreements[to].valuationCap = agreements[from].valuationCap;\n            agreements[to].discount = agreements[from].discount;\n        }\n\n        emit Transfer(from, to, amount);\n    }\n\n    function getAgreementsCount() external view returns (uint agreementsCount) {\n        return allAgreements.length;\n    }\n\n    // UI helper fx - Returns all agreements from offset as\n    // [index in allAgreements, account address as uint, balance, agreementHash as uint,\n    //          discount as uint, valuationCap as uint ]\n    function getAllAgreements(uint offset) external view returns(uint[6][CHUNK_SIZE] agreementsResult) {\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allAgreements.length; i++) {\n            address agreementAccount = allAgreements[i + offset];\n            Agreement storage agreement = agreements[agreementAccount];\n            agreementsResult[i] = [ i + offset, uint(agreementAccount), agreement.balance,\n                uint(agreement.agreementHash), uint(agreement.discount), uint(agreement.valuationCap)];\n        }\n    }\n\n}\n"
        }
      }
    }
  }
}