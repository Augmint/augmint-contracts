{
  "contractName": "LoanManager",
  "latestAbiHash": "291572b8d2ffe95dca1733ebc1472e08",
  "deployedAbis": {
    "dd8d5ec97e0a22b6f9e63b04d4e11e09": {
      "latestDeployedAddress": "0x72ab340874d8189778d5b4def3eaabc9069da7f2",
      "deployments": {
        "0x72ab340874d8189778d5b4def3eaabc9069da7f2": {
          "generatedAt": "2018-04-25T12:29:07.585Z",
          "truffleContractFileUpdatedAt": "2018-02-14T23:28:03.482Z",
          "compiler": {
            "name": "solc",
            "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
          },
          "bytecodeHash": "aa67baec70431e71c2be8d412df7f2d8",
          "deployedBytecodeHash": "9906a9c556eabbf516789bbd2510ca24",
          "sourceHash": "759bfe882bcce74bc3b207640322e232",
          "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - interestEarnedAccount setter?\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - create and use InterestEarnedAccount interface instead?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity 0.4.19;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./InterestEarnedAccount.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted {\n    using SafeMath for uint256;\n\n    enum LoanState { Open, Repaid, Defaulted }\n\n    struct LoanProduct {\n        uint term; // 0\n        uint discountRate; // 1: discountRate in parts per million , ie. 10,000 = 1%\n        uint collateralRatio;   // 2: loan token amount / colleteral pegged ccy value\n                                // in parts per million , ie. 10,000 = 1%\n        uint minDisbursedAmount; // 3: with 4 decimals, e.g. 31000 = 3.1ACE\n        uint defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive; // 5\n    }\n\n    struct LoanData {\n        address borrower; // 0\n        LoanState state; // 1\n        uint collateralAmount; // 2\n        uint repaymentAmount; // 3\n        uint loanAmount; // 4\n        uint interestAmount; // 5\n        uint term; // 6\n        uint disbursementDate; // 7\n        uint maturity; // 8\n        uint defaultingFeePt; // 9\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public mLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n    InterestEarnedAccount public interestEarnedAccount;\n\n    event NewLoan(uint productId, uint loanId, address borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount);\n\n    event LoanProductActiveStateChanged(uint productId, bool newState);\n\n    event LoanProductAdded(uint productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint indexed loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    function LoanManager(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor, Rates _rates,\n                            InterestEarnedAccount _interestEarnedAccount)\n    public {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n        interestEarnedAccount = _interestEarnedAccount;\n    }\n\n    function addLoanProduct(uint _term, uint _discountRate, uint _collateralRatio, uint _minDisbursedAmount,\n        uint _defaultingFee, bool _isActive)\n    external restrict(\"MonetaryBoard\") returns (uint newProductId) {\n        newProductId = products.push(\n            LoanProduct(_term, _discountRate, _collateralRatio, _minDisbursedAmount, _defaultingFee, _isActive)\n        ) - 1;\n\n        LoanProductAdded(newProductId);\n        return newProductId;\n    }\n\n    function setLoanProductActiveState(uint8 productId, bool newState)\n    external restrict (\"MonetaryBoard\") {\n        products[productId].isActive = false;\n        LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint8 productId) external payable {\n        require(products[productId].isActive); // valid productId?\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(products[productId].collateralRatio).roundedDiv(100000000);\n        repaymentAmount = repaymentAmount * 100;    // rounding 4 decimals value to 2 decimals.\n                                                    // no safe mul needed b/c of prev divide\n\n        uint mul = products[productId].collateralRatio.mul(products[productId].discountRate) / 1000000;\n        uint loanAmount = tokenValue.mul(mul).roundedDiv(100000000);\n        loanAmount = loanAmount * 100;  // rounding 4 decimals value to 2 decimals.\n                                        // no safe mul needed b/c of prev divide\n\n        require(loanAmount >= products[productId].minDisbursedAmount);\n        uint interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n\n        // Create new loan\n        uint loanId = loans.push(\n            LoanData(msg.sender, LoanState.Open, msg.value, repaymentAmount, loanAmount,\n                interestAmount, products[productId].term, now, now + products[productId].term,\n                products[productId].defaultingFeePt)\n            ) - 1;\n\n        // Store ref to new loan\n        mLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        for (uint i = 0; i < loanIds.length; i++) {\n            uint loanId = loanIds[i];\n            require(loans[loanId].state == LoanState.Open);\n            require(now >= loans[loanId].maturity);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loans[loanId].loanAmount);\n\n            loans[loanId].state = LoanState.Defaulted;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loans[loanId].repaymentAmount.mul(loans[loanId].defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(), loans[loanId].repaymentAmount)\n                .add(defaultingFee);\n            uint releasedCollateral;\n            if (targetCollection < loans[loanId].collateralAmount) {\n                releasedCollateral = loans[loanId].collateralAmount.sub(targetCollection);\n                loans[loanId].borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loans[loanId].collateralAmount.sub(releasedCollateral);\n            if (defaultingFee > collateralToCollect) {\n                defaultingFee = collateralToCollect;\n            }\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            LoanCollected(loanId, loans[loanId].borrower, collateralToCollect, releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            monetarySupervisor.augmintReserves().transfer(totalCollateralToCollect);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    function getLoanCount() external view returns (uint ct) {\n        return loans.length;\n    }\n\n    function getProductCount() external view returns (uint ct) {\n        return products.length;\n    }\n\n    function getLoanIds(address borrower) external view returns (uint[] _loans) {\n        return mLoans[borrower];\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) public {\n        require(msg.sender == address(augmintToken));\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        require(loans[loanId].state == LoanState.Open);\n        require(now <= loans[loanId].maturity);\n        require(loans[loanId].repaymentAmount == repaymentAmount);\n        loans[loanId].state = LoanState.Repaid;\n\n        augmintToken.transfer(interestEarnedAccount, loans[loanId].interestAmount);\n\n        augmintToken.burn(loans[loanId].loanAmount);\n        monetarySupervisor.loanRepaymentNotification(loans[loanId].loanAmount); // update KPIs\n\n        loans[loanId].borrower.transfer(loans[loanId].collateralAmount); // send back ETH collateral\n\n        LoanRepayed(loanId, loans[loanId].borrower);\n    }\n\n}\n"
        }
      }
    },
    "d72d3bd9689dba0d1a8cd4ec23757257": {
      "latestDeployedAddress": "0x6d3c4ce65b4b1267804e011120f3359d44a3a1a3",
      "deployments": {
        "0x6d3c4ce65b4b1267804e011120f3359d44a3a1a3": {
          "generatedAt": "2018-04-25T12:30:49.374Z",
          "truffleContractFileUpdatedAt": "2018-02-27T07:36:28.169Z",
          "compiler": {
            "name": "solc",
            "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
          },
          "bytecodeHash": "9aa1d3b1d7b1c4593514e33e4854ac41",
          "deployedBytecodeHash": "60180139c1bd8c2e65ca93a4a5023884",
          "sourceHash": "5663e971bf347b437fd2860c13e65ea1",
          "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - interestEarnedAccount setter?\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - create and use InterestEarnedAccount interface instead?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity 0.4.19;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./InterestEarnedAccount.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted {\n    using SafeMath for uint256;\n\n    uint16 public constant CHUNK_SIZE = 100;\n\n    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n\n    struct LoanProduct {\n        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n        uint32 term;            // 1\n        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n                                //      in parts per million , ie. 10,000 = 1%\n        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive;          // 5\n    }\n\n    /* NB: we don't need to store loan parameters because loan products can't be altered (only disabled/enabled) */\n    struct LoanData {\n        uint collateralAmount; // 0\n        uint repaymentAmount; // 1\n        address borrower; // 2\n        uint32 productId; // 3\n        LoanState state; // 4\n        uint40 maturity; // 5\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n    InterestEarnedAccount public interestEarnedAccount;\n\n    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount, uint40 maturity);\n\n    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n\n    event LoanProductAdded(uint32 productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    function LoanManager(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor, Rates _rates,\n                            InterestEarnedAccount _interestEarnedAccount)\n    public {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n        interestEarnedAccount = _interestEarnedAccount;\n    }\n\n    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n                                uint32 defaultingFeePt, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newProductId = products.push(\n            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n        ) - 1;\n\n        uint32 newProductId = uint32(_newProductId);\n        require(newProductId == _newProductId);\n\n        LoanProductAdded(newProductId);\n    }\n\n    function setLoanProductActiveState(uint32 productId, bool newState)\n    external restrict (\"MonetaryBoard\") {\n        products[productId].isActive = false;\n        LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint32 productId) external payable {\n        LoanProduct storage product = products[productId];\n        require(product.isActive); // valid productId?\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n\n        uint loanAmount;\n        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n\n        require(loanAmount >= product.minDisbursedAmount);\n\n        uint expiration = now.add(product.term);\n        uint40 maturity = uint40(expiration);\n        require(maturity == expiration);\n\n        // Create new loan\n        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n                                            productId, LoanState.Open, maturity)) - 1;\n\n        // Store ref to new loan\n        accountLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        for (uint i = 0; i < loanIds.length; i++) {\n            LoanData storage loan = loans[loanIds[i]];\n            require(loan.state == LoanState.Open);\n            require(now >= loan.maturity);\n            LoanProduct storage product = products[loan.productId];\n\n            uint loanAmount;\n            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n\n            loan.state = LoanState.Collected;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n                                                            loan.repaymentAmount).add(defaultingFee);\n\n            uint releasedCollateral;\n            if (targetCollection < loan.collateralAmount) {\n                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n                loan.borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n            if (defaultingFee > collateralToCollect) {\n                defaultingFee = collateralToCollect;\n            }\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            LoanCollected(loanIds[i], loan.borrower, collateralToCollect, releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            monetarySupervisor.augmintReserves().transfer(totalCollateralToCollect);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    function getProductCount() external view returns (uint ct) {\n        return products.length;\n    }\n\n    // returns CHUNK_SIZE loan products starting from some offset:\n    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive ]\n    function getProducts(uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= products.length) { break; }\n\n            LoanProduct storage product = products[offset + i];\n\n            response[i] = [offset + i, product.minDisbursedAmount, product.term, product.discountRate,\n                                product.collateralRatio, product.defaultingFeePt, product.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLoanCount() external view returns (uint ct) {\n        return loans.length;\n    }\n\n    /* returns CHUNK_SIZE loans starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ]   */\n    function getLoans(uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loans.length) { break; }\n\n            response[i] = getLoanTuple(offset + i);\n        }\n    }\n\n    function getLoanCountForAddress(address borrower) external view returns (uint) {\n        return accountLoans[borrower].length;\n    }\n\n    /* returns CHUNK_SIZE loans of a given account, starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ] */\n    function getLoansForAddress(address borrower, uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        uint[] storage loansForAddress = accountLoans[borrower];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loansForAddress.length) { break; }\n\n            response[i] = getLoanTuple(loansForAddress[offset + i]);\n        }\n    }\n\n    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n        LoanData storage loan = loans[loanId];\n        LoanProduct storage product = products[loan.productId];\n\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n        uint disbursementTime = loan.maturity - product.term;\n\n        LoanState loanState =\n                        loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n\n        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n                    loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) public {\n        require(msg.sender == address(augmintToken));\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n    internal view returns (uint loanAmount, uint interestAmount) {\n        // calculate loan values based on repayment amount\n        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        LoanData storage loan = loans[loanId];\n        require(loan.state == LoanState.Open);\n        require(repaymentAmount == loan.repaymentAmount);\n        require(now <= loan.maturity);\n\n        LoanProduct storage product = products[loan.productId];\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n\n        loans[loanId].state = LoanState.Repaid;\n\n        if (interestAmount > 0) {\n            augmintToken.transfer(interestEarnedAccount, interestAmount);\n            augmintToken.burn(loanAmount);\n        } else {\n            // negative or zero interest (i.e. discountRate >= 0)\n            augmintToken.burn(repaymentAmount);\n        }\n\n        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n\n        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n\n        LoanRepayed(loanId, loan.borrower);\n    }\n\n}\n"
        }
      }
    },
    "291572b8d2ffe95dca1733ebc1472e08": {
      "latestDeployedAddress": "0x9b17fd903246da0b0304e0e984389dabd1ae6a8c",
      "deployments": {
        "0x9b17fd903246da0b0304e0e984389dabd1ae6a8c": {
          "generatedAt": "2018-04-26T14:50:56.186Z",
          "truffleContractFileUpdatedAt": "2018-04-26T14:50:44.207Z",
          "deployTransactionHash": "0xe9760ff3fc6981a8e1c951cff90306e281159792287d53eb4565783c68200030",
          "compiler": {
            "name": "solc",
            "version": "0.4.23+commit.124ca40d.Emscripten.clang"
          },
          "bytecodeHash": "9b2af2190d11f139267470192e159dae",
          "deployedBytecodeHash": "efd0e7f623cf1fab5dbce721e75be938",
          "sourceHash": "9d5f96db98b6d336c18b8c6df5c7cd92",
          "source": "/*\n    Contract to manage Augmint token loan contracts backed by ETH\n    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n\n    TODO:\n        - create MonetarySupervisor interface and use it instead?\n        - make data arg generic bytes?\n        - make collect() run as long as gas provided allows\n*/\npragma solidity ^0.4.23;\n\nimport \"./Rates.sol\";\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\n\n\ncontract LoanManager is Restricted {\n    using SafeMath for uint256;\n\n    uint16 public constant CHUNK_SIZE = 100;\n\n    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n\n    struct LoanProduct {\n        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n        uint32 term;            // 1\n        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n                                //      in parts per million , ie. 10,000 = 1%\n        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n        bool isActive;          // 5\n    }\n\n    /* NB: we don't need to store loan parameters because loan products can't be altered (only disabled/enabled) */\n    struct LoanData {\n        uint collateralAmount; // 0\n        uint repaymentAmount; // 1\n        address borrower; // 2\n        uint32 productId; // 3\n        LoanState state; // 4\n        uint40 maturity; // 5\n    }\n\n    LoanProduct[] public products;\n\n    LoanData[] public loans;\n    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n\n    Rates public rates; // instance of ETH/pegged currency rate provider contract\n    AugmintTokenInterface public augmintToken; // instance of token contract\n    MonetarySupervisor public monetarySupervisor;\n\n    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n        uint repaymentAmount, uint40 maturity);\n\n    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n\n    event LoanProductAdded(uint32 productId);\n\n    event LoanRepayed(uint loanId, address borrower);\n\n    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n        uint releasedCollateral, uint defaultingFee);\n\n    event SystemContractsChanged(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor);\n\n    constructor(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor, Rates _rates)\n    public {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n        rates = _rates;\n    }\n\n    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n                                uint32 defaultingFeePt, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newProductId = products.push(\n            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n        ) - 1;\n\n        uint32 newProductId = uint32(_newProductId);\n        require(newProductId == _newProductId, \"productId overflow\");\n\n        emit LoanProductAdded(newProductId);\n    }\n\n    function setLoanProductActiveState(uint32 productId, bool newState)\n    external restrict (\"MonetaryBoard\") {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        products[productId].isActive = false;\n        emit LoanProductActiveStateChanged(productId, newState);\n    }\n\n    function newEthBackedLoan(uint32 productId) external payable {\n        require(productId < products.length, \"invalid productId\"); // next line would revert but require to emit reason\n        LoanProduct storage product = products[productId];\n        require(product.isActive, \"product must be in active state\"); // valid product\n\n\n        // calculate loan values based on ETH sent in with Tx\n        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n\n        uint loanAmount;\n        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n\n        require(loanAmount >= product.minDisbursedAmount, \"loanAmount must be >= minDisbursedAmount\");\n\n        uint expiration = now.add(product.term);\n        uint40 maturity = uint40(expiration);\n        require(maturity == expiration, \"maturity overflow\");\n\n        // Create new loan\n        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n                                            productId, LoanState.Open, maturity)) - 1;\n\n        // Store ref to new loan\n        accountLoans[msg.sender].push(loanId);\n\n        // Issue tokens and send to borrower\n        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n\n        emit NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n    }\n\n    /* repay loan, called from AugmintToken's transferAndNotify\n     Flow for repaying loan:\n        1) user calls token contract's transferAndNotify loanId passed in data arg\n        2) transferAndNotify transfers tokens to the Lender contract\n        3) transferAndNotify calls Lender.transferNotification with lockProductId\n    */\n    // from arg is not used as we allow anyone to repay a loan:\n    function transferNotification(address, uint repaymentAmount, uint loanId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n\n        _repayLoan(loanId, repaymentAmount);\n    }\n\n    function collect(uint[] loanIds) external {\n        /* when there are a lots of loans to be collected then\n             the client need to call it in batches to make sure tx won't exceed block gas limit.\n         Anyone can call it - can't cause harm as it only allows to collect loans which they are defaulted\n         TODO: optimise defaulting fee calculations\n        */\n        uint totalLoanAmountCollected;\n        uint totalCollateralToCollect;\n        uint totalDefaultingFee;\n        for (uint i = 0; i < loanIds.length; i++) {\n            require(i < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n            LoanData storage loan = loans[loanIds[i]];\n            require(loan.state == LoanState.Open, \"loan state must be Open\");\n            require(now >= loan.maturity, \"current time must be later than maturity\");\n            LoanProduct storage product = products[loan.productId];\n\n            uint loanAmount;\n            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n\n            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n\n            loan.state = LoanState.Collected;\n\n            // send ETH collateral to augmintToken reserve\n            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n                                                            loan.repaymentAmount).add(defaultingFee);\n\n            uint releasedCollateral;\n            if (targetCollection < loan.collateralAmount) {\n                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n                loan.borrower.transfer(releasedCollateral);\n            }\n            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n            if (defaultingFee >= collateralToCollect) {\n                defaultingFee = collateralToCollect;\n                collateralToCollect = 0;\n            } else {\n                collateralToCollect = collateralToCollect.sub(defaultingFee);\n            }\n            totalDefaultingFee = totalDefaultingFee.add(defaultingFee);\n\n            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n\n            emit LoanCollected(loanIds[i], loan.borrower, collateralToCollect.add(defaultingFee), releasedCollateral, defaultingFee);\n        }\n\n        if (totalCollateralToCollect > 0) {\n            address(monetarySupervisor.augmintReserves()).transfer(totalCollateralToCollect);\n        }\n\n        if (totalDefaultingFee > 0){\n            address(augmintToken.feeAccount()).transfer(totalDefaultingFee);\n        }\n\n        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n\n    }\n\n    /* to allow upgrade of Rates and MonetarySupervisor contracts */\n    function setSystemContracts(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor)\n    external restrict(\"MonetaryBoard\") {\n        rates = newRatesContract;\n        monetarySupervisor = newMonetarySupervisor;\n        emit SystemContractsChanged(newRatesContract, newMonetarySupervisor);\n    }\n\n    function getProductCount() external view returns (uint ct) {\n        return products.length;\n    }\n\n    // returns CHUNK_SIZE loan products starting from some offset:\n    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, maxLoanAmount, isActive ]\n    function getProducts(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= products.length) { break; }\n\n            LoanProduct storage product = products[offset + i];\n\n            response[i] = [offset + i, product.minDisbursedAmount, product.term, product.discountRate,\n                            product.collateralRatio, product.defaultingFeePt,\n                            monetarySupervisor.getMaxLoanAmount(product.minDisbursedAmount), product.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLoanCount() external view returns (uint ct) {\n        return loans.length;\n    }\n\n    /* returns CHUNK_SIZE loans starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ]   */\n    function getLoans(uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loans.length) { break; }\n\n            response[i] = getLoanTuple(offset + i);\n        }\n    }\n\n    function getLoanCountForAddress(address borrower) external view returns (uint) {\n        return accountLoans[borrower].length;\n    }\n\n    /* returns CHUNK_SIZE loans of a given account, starting from some offset. Loans data encoded as:\n        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n                                                                                    loanAmount, interestAmount ] */\n    function getLoansForAddress(address borrower, uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n\n        uint[] storage loansForAddress = accountLoans[borrower];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= loansForAddress.length) { break; }\n\n            response[i] = getLoanTuple(loansForAddress[offset + i]);\n        }\n    }\n\n    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        LoanProduct storage product = products[loan.productId];\n\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n        uint disbursementTime = loan.maturity - product.term;\n\n        LoanState loanState =\n                        loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n\n        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n                    loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n    }\n\n    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n    internal view returns (uint loanAmount, uint interestAmount) {\n        // calculate loan values based on repayment amount\n        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n    }\n\n    /* internal function, assuming repayment amount already transfered  */\n    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n        require(loanId < loans.length, \"invalid loanId\"); // next line would revert but require to emit reason\n        LoanData storage loan = loans[loanId];\n        require(loan.state == LoanState.Open, \"loan state must be Open\");\n        require(repaymentAmount == loan.repaymentAmount, \"repaymentAmount must be equal to tokens sent\");\n        require(now <= loan.maturity, \"current time must be earlier than maturity\");\n\n        LoanProduct storage product = products[loan.productId];\n        uint loanAmount;\n        uint interestAmount;\n        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n\n        loans[loanId].state = LoanState.Repaid;\n\n        if (interestAmount > 0) {\n            augmintToken.transfer(monetarySupervisor.interestEarnedAccount(), interestAmount);\n            augmintToken.burn(loanAmount);\n        } else {\n            // negative or zero interest (i.e. discountRate >= 0)\n            augmintToken.burn(repaymentAmount);\n        }\n\n        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n\n        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n\n        emit LoanRepayed(loanId, loan.borrower);\n    }\n\n}\n"
        }
      }
    }
  }
}