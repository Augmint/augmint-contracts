/*
 WIP, first pass proof of concept. Implementation will change a lot.

 TODO:
  - No point to have this as a separate contract unless:
     - we make it generic, i.e. any arbitary calldata can be signed
     - make it changeable on AugmintToken
  - Maybe reorg some parts to interfaces/abstract contract/lib and use it directly on AugmintToken?
  - Double check if we don't  need to add network id to signed data:
    In addition to being implicitly stored in the augmintTokenaddress (ie. deployment address is unique),
    the chain id is also explicitly stored in the v parameter (chain_id = (v - 35) / 2).
  - test signing with trezor signature:
    https://github.com/0xProject/0x-monorepo/blob/095388ffe05ca51e92db87ba81d6e4f29b1ab087/packages/contracts/src/contracts/current/protocol/Exchange/MixinSignatureValidator.sol

  - EIP712 & ERC191 signature schemes?
*/
pragma solidity 0.4.23;

import "./generic/SafeMath.sol";
import "./interfaces/AugmintTokenInterface.sol";

contract TxDelegator {
    using SafeMath for uint256;
    mapping(bytes32 => bool) public noncesUsed;

    function delegatedTransfer(AugmintTokenInterface augmintToken, address from, address to, uint amount, string narrative,
                                 uint minGasPrice,  /* client provided gasPrice on which she expects tx to be exec. */
                                 uint maxExecutorFee, /* client provided max fee for executing the tx */
                                 bytes32 nonce, /* random nonce generated by client */
                                 /* ^^^^ end of signed data ^^^^ */
                                 bytes signature,
                                 uint requestedExecutorFee /* the executor can decide to request lower fee */
                                 )
    external {
        require(!noncesUsed[nonce], "nonce already used");
        require(tx.gasprice >= minGasPrice, "tx.gasprice must be >= minGasPrice");
        require(requestedExecutorFee <= maxExecutorFee, "requestedExecutorFee must be <= maxExecutorFee");
        noncesUsed[nonce] = true;

        bytes32 txHash = keccak256(this, augmintToken, from, to, amount, narrative, minGasPrice, maxExecutorFee, nonce);
        txHash = keccak256("\x19Ethereum Signed Message:\n32", txHash);

        address recovered = recover(txHash, signature);

        require(recovered == from, "invalid signature");

        require(augmintToken.delegatedTransferExecution(from, to, amount, narrative, requestedExecutorFee),
                    "delegatedTransferExecution failed");

    }

    /* from: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ECRecovery.sol  */
    function recover(bytes32 hash, bytes sig) internal pure returns (address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        //Check the signature length
        if (sig.length != 65) {
            return (address(0));
        }

        // Divide the signature in r, s and v variables
        assembly { // solhint-disable-line no-inline-assembly
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }

        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
        if (v < 27) {
            v += 27;
        }

        // If the version is correct return the signer address
        if (v != 27 && v != 28) {
            return (address(0));
        } else {
            return ecrecover(hash, v, r, s);
        }
    }

}
